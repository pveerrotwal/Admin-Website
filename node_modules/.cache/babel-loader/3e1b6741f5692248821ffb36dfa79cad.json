{"ast":null,"code":"import { normSpaces, IN_BROWSER, getLabelAttribute, now } from '../utils.js';\nimport { hasTag } from '../app/guards.js';\nimport { InputChange, SetInputValue, SetInputChecked } from '../app/messages.gen.js';\nconst INPUT_TYPES = ['text', 'password', 'email', 'search', 'number', 'range', 'date', 'tel', 'time'];\nfunction isTextFieldElement(node) {\n  if (hasTag(node, 'textarea')) {\n    return true;\n  }\n  if (!hasTag(node, 'input')) {\n    return false;\n  }\n  return INPUT_TYPES.includes(node.type);\n}\nfunction isCheckbox(node) {\n  if (!hasTag(node, 'input')) {\n    return false;\n  }\n  const type = node.type;\n  return type === 'checkbox' || type === 'radio';\n}\nconst labelElementFor = IN_BROWSER && 'labels' in HTMLInputElement.prototype ? node => {\n  let p = node;\n  while ((p = p.parentNode) !== null) {\n    if (hasTag(p, 'label')) {\n      return p;\n    }\n  }\n  const labels = node.labels;\n  if (labels !== null && labels.length === 1) {\n    return labels[0];\n  }\n} : node => {\n  let p = node;\n  while ((p = p.parentNode) !== null) {\n    if (hasTag(p, 'label')) {\n      return p;\n    }\n  }\n  const id = node.id;\n  if (id) {\n    const labels = node.ownerDocument.querySelectorAll('label[for=\"' + id + '\"]');\n    if (labels !== null && labels.length === 1) {\n      return labels[0];\n    }\n  }\n};\nexport function getInputLabel(node) {\n  let label = getLabelAttribute(node);\n  if (label === null) {\n    const labelElement = labelElementFor(node);\n    label = labelElement && labelElement.innerText || node.placeholder || node.name || node.id || node.className || node.type;\n  }\n  return normSpaces(label).slice(0, 100);\n}\nexport const InputMode = {\n  Plain: 0,\n  Obscured: 1,\n  Hidden: 2\n};\nexport default function (app, opts) {\n  const options = Object.assign({\n    obscureInputNumbers: true,\n    obscureInputEmails: true,\n    defaultInputMode: InputMode.Obscured,\n    obscureInputDates: false\n  }, opts);\n  function getInputValue(id, node) {\n    let value = node.value;\n    let inputMode = options.defaultInputMode;\n    if (node.type === 'password' || app.sanitizer.isHidden(id)) {\n      inputMode = InputMode.Hidden;\n    } else if (app.sanitizer.isObscured(id) || inputMode === InputMode.Plain && (options.obscureInputNumbers && node.type !== 'date' && /\\d\\d\\d\\d/.test(value) || options.obscureInputDates && node.type === 'date' || options.obscureInputEmails && (node.type === 'email' || !!~value.indexOf('@')))) {\n      inputMode = InputMode.Obscured;\n    }\n    let mask = 0;\n    switch (inputMode) {\n      case InputMode.Hidden:\n        mask = -1;\n        value = '';\n        break;\n      case InputMode.Obscured:\n        mask = value.length;\n        value = '';\n        break;\n    }\n    return {\n      value,\n      mask\n    };\n  }\n  function sendInputValue(id, node) {\n    const {\n      value,\n      mask\n    } = getInputValue(id, node);\n    app.send(SetInputValue(id, value, mask));\n  }\n  const inputValues = new Map();\n  const checkboxValues = new Map();\n  app.attachStopCallback(() => {\n    inputValues.clear();\n    checkboxValues.clear();\n  });\n  function trackInputValue(id, node) {\n    if (inputValues.get(id) === node.value) {\n      return;\n    }\n    inputValues.set(id, node.value);\n    sendInputValue(id, node);\n  }\n  function trackCheckboxValue(id, value) {\n    if (checkboxValues.get(id) === value) {\n      return;\n    }\n    checkboxValues.set(id, value);\n    app.send(SetInputChecked(id, value));\n  }\n  // The only way (to our knowledge) to track all kinds of input changes, including those made by JS\n  app.ticker.attach(() => {\n    inputValues.forEach((value, id) => {\n      const node = app.nodes.getNode(id);\n      if (!node) return inputValues.delete(id);\n      trackInputValue(id, node);\n    });\n    checkboxValues.forEach((checked, id) => {\n      const node = app.nodes.getNode(id);\n      if (!node) return checkboxValues.delete(id);\n      trackCheckboxValue(id, node.checked);\n    });\n  }, 3);\n  function sendInputChange(id, node, hesitationTime, inputTime) {\n    const {\n      value,\n      mask\n    } = getInputValue(id, node);\n    const label = getInputLabel(node);\n    app.send(InputChange(id, value, mask !== 0, label, hesitationTime, inputTime));\n  }\n  app.nodes.attachNodeCallback(app.safe(node => {\n    const id = app.nodes.getID(node);\n    if (id === undefined) {\n      return;\n    }\n    // TODO: support multiple select (?): use selectedOptions;\n    if (hasTag(node, 'select')) {\n      sendInputValue(id, node);\n      app.nodes.attachNodeListener(node, 'change', () => sendInputValue(id, node));\n    }\n    if (isTextFieldElement(node)) {\n      trackInputValue(id, node);\n      let nodeFocusTime = 0;\n      let nodeHesitationTime = 0;\n      let inputTime = 0;\n      const onFocus = () => {\n        nodeFocusTime = now();\n      };\n      const onInput = () => {\n        if (nodeHesitationTime === 0 && nodeFocusTime !== 0) {\n          nodeHesitationTime = now() - nodeFocusTime;\n        }\n      };\n      const onChange = () => {\n        if (nodeFocusTime !== 0) {\n          inputTime = now() - nodeFocusTime;\n        }\n        sendInputChange(id, node, nodeHesitationTime, inputTime);\n        nodeHesitationTime = 0;\n        inputTime = 0;\n        nodeFocusTime = 0;\n      };\n      app.nodes.attachNodeListener(node, 'focus', onFocus);\n      app.nodes.attachNodeListener(node, 'input', onInput);\n      app.nodes.attachNodeListener(node, 'change', onChange);\n      return;\n    }\n    if (isCheckbox(node)) {\n      trackCheckboxValue(id, node.checked);\n      app.nodes.attachNodeListener(node, 'change', () => trackCheckboxValue(id, node.checked));\n      return;\n    }\n  }));\n}","map":{"version":3,"names":["normSpaces","IN_BROWSER","getLabelAttribute","now","hasTag","InputChange","SetInputValue","SetInputChecked","INPUT_TYPES","isTextFieldElement","node","includes","type","isCheckbox","labelElementFor","HTMLInputElement","prototype","p","parentNode","labels","length","id","ownerDocument","querySelectorAll","getInputLabel","label","labelElement","innerText","placeholder","name","className","slice","InputMode","Plain","Obscured","Hidden","app","opts","options","Object","assign","obscureInputNumbers","obscureInputEmails","defaultInputMode","obscureInputDates","getInputValue","value","inputMode","sanitizer","isHidden","isObscured","test","indexOf","mask","sendInputValue","send","inputValues","Map","checkboxValues","attachStopCallback","clear","trackInputValue","get","set","trackCheckboxValue","ticker","attach","forEach","nodes","getNode","delete","checked","sendInputChange","hesitationTime","inputTime","attachNodeCallback","safe","getID","undefined","attachNodeListener","nodeFocusTime","nodeHesitationTime","onFocus","onInput","onChange"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/lib/modules/input.js"],"sourcesContent":["import { normSpaces, IN_BROWSER, getLabelAttribute, now } from '../utils.js';\nimport { hasTag } from '../app/guards.js';\nimport { InputChange, SetInputValue, SetInputChecked } from '../app/messages.gen.js';\nconst INPUT_TYPES = [\n    'text',\n    'password',\n    'email',\n    'search',\n    'number',\n    'range',\n    'date',\n    'tel',\n    'time',\n];\nfunction isTextFieldElement(node) {\n    if (hasTag(node, 'textarea')) {\n        return true;\n    }\n    if (!hasTag(node, 'input')) {\n        return false;\n    }\n    return INPUT_TYPES.includes(node.type);\n}\nfunction isCheckbox(node) {\n    if (!hasTag(node, 'input')) {\n        return false;\n    }\n    const type = node.type;\n    return type === 'checkbox' || type === 'radio';\n}\nconst labelElementFor = IN_BROWSER && 'labels' in HTMLInputElement.prototype\n    ? (node) => {\n        let p = node;\n        while ((p = p.parentNode) !== null) {\n            if (hasTag(p, 'label')) {\n                return p;\n            }\n        }\n        const labels = node.labels;\n        if (labels !== null && labels.length === 1) {\n            return labels[0];\n        }\n    }\n    : (node) => {\n        let p = node;\n        while ((p = p.parentNode) !== null) {\n            if (hasTag(p, 'label')) {\n                return p;\n            }\n        }\n        const id = node.id;\n        if (id) {\n            const labels = node.ownerDocument.querySelectorAll('label[for=\"' + id + '\"]');\n            if (labels !== null && labels.length === 1) {\n                return labels[0];\n            }\n        }\n    };\nexport function getInputLabel(node) {\n    let label = getLabelAttribute(node);\n    if (label === null) {\n        const labelElement = labelElementFor(node);\n        label =\n            (labelElement && labelElement.innerText) ||\n                node.placeholder ||\n                node.name ||\n                node.id ||\n                node.className ||\n                node.type;\n    }\n    return normSpaces(label).slice(0, 100);\n}\nexport const InputMode = {\n    Plain: 0,\n    Obscured: 1,\n    Hidden: 2,\n};\nexport default function (app, opts) {\n    const options = Object.assign({\n        obscureInputNumbers: true,\n        obscureInputEmails: true,\n        defaultInputMode: InputMode.Obscured,\n        obscureInputDates: false,\n    }, opts);\n    function getInputValue(id, node) {\n        let value = node.value;\n        let inputMode = options.defaultInputMode;\n        if (node.type === 'password' || app.sanitizer.isHidden(id)) {\n            inputMode = InputMode.Hidden;\n        }\n        else if (app.sanitizer.isObscured(id) ||\n            (inputMode === InputMode.Plain &&\n                ((options.obscureInputNumbers && node.type !== 'date' && /\\d\\d\\d\\d/.test(value)) ||\n                    (options.obscureInputDates && node.type === 'date') ||\n                    (options.obscureInputEmails && (node.type === 'email' || !!~value.indexOf('@')))))) {\n            inputMode = InputMode.Obscured;\n        }\n        let mask = 0;\n        switch (inputMode) {\n            case InputMode.Hidden:\n                mask = -1;\n                value = '';\n                break;\n            case InputMode.Obscured:\n                mask = value.length;\n                value = '';\n                break;\n        }\n        return { value, mask };\n    }\n    function sendInputValue(id, node) {\n        const { value, mask } = getInputValue(id, node);\n        app.send(SetInputValue(id, value, mask));\n    }\n    const inputValues = new Map();\n    const checkboxValues = new Map();\n    app.attachStopCallback(() => {\n        inputValues.clear();\n        checkboxValues.clear();\n    });\n    function trackInputValue(id, node) {\n        if (inputValues.get(id) === node.value) {\n            return;\n        }\n        inputValues.set(id, node.value);\n        sendInputValue(id, node);\n    }\n    function trackCheckboxValue(id, value) {\n        if (checkboxValues.get(id) === value) {\n            return;\n        }\n        checkboxValues.set(id, value);\n        app.send(SetInputChecked(id, value));\n    }\n    // The only way (to our knowledge) to track all kinds of input changes, including those made by JS\n    app.ticker.attach(() => {\n        inputValues.forEach((value, id) => {\n            const node = app.nodes.getNode(id);\n            if (!node)\n                return inputValues.delete(id);\n            trackInputValue(id, node);\n        });\n        checkboxValues.forEach((checked, id) => {\n            const node = app.nodes.getNode(id);\n            if (!node)\n                return checkboxValues.delete(id);\n            trackCheckboxValue(id, node.checked);\n        });\n    }, 3);\n    function sendInputChange(id, node, hesitationTime, inputTime) {\n        const { value, mask } = getInputValue(id, node);\n        const label = getInputLabel(node);\n        app.send(InputChange(id, value, mask !== 0, label, hesitationTime, inputTime));\n    }\n    app.nodes.attachNodeCallback(app.safe((node) => {\n        const id = app.nodes.getID(node);\n        if (id === undefined) {\n            return;\n        }\n        // TODO: support multiple select (?): use selectedOptions;\n        if (hasTag(node, 'select')) {\n            sendInputValue(id, node);\n            app.nodes.attachNodeListener(node, 'change', () => sendInputValue(id, node));\n        }\n        if (isTextFieldElement(node)) {\n            trackInputValue(id, node);\n            let nodeFocusTime = 0;\n            let nodeHesitationTime = 0;\n            let inputTime = 0;\n            const onFocus = () => {\n                nodeFocusTime = now();\n            };\n            const onInput = () => {\n                if (nodeHesitationTime === 0 && nodeFocusTime !== 0) {\n                    nodeHesitationTime = now() - nodeFocusTime;\n                }\n            };\n            const onChange = () => {\n                if (nodeFocusTime !== 0) {\n                    inputTime = now() - nodeFocusTime;\n                }\n                sendInputChange(id, node, nodeHesitationTime, inputTime);\n                nodeHesitationTime = 0;\n                inputTime = 0;\n                nodeFocusTime = 0;\n            };\n            app.nodes.attachNodeListener(node, 'focus', onFocus);\n            app.nodes.attachNodeListener(node, 'input', onInput);\n            app.nodes.attachNodeListener(node, 'change', onChange);\n            return;\n        }\n        if (isCheckbox(node)) {\n            trackCheckboxValue(id, node.checked);\n            app.nodes.attachNodeListener(node, 'change', () => trackCheckboxValue(id, node.checked));\n            return;\n        }\n    }));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}