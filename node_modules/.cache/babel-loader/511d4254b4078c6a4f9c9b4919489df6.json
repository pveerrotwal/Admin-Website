{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchProxyHandler = exports.ResponseProxyHandler = void 0;\n/**\n * I took inspiration in few stack exchange posts\n * and Tencent vConsole library (MIT)\n * by wrapping the XMLHttpRequest object in a Proxy\n * we can intercept the network requests\n * in not-so-hacky way\n * */\nconst networkMessage_js_1 = __importStar(require(\"./networkMessage.js\"));\nconst utils_js_1 = require(\"./utils.js\");\nclass ResponseProxyHandler {\n  constructor(resp, item) {\n    this.resp = resp;\n    this.item = item;\n    this.mockReader();\n  }\n  set(target, key, value) {\n    return Reflect.set(target, key, value);\n  }\n  get(target, key) {\n    const value = Reflect.get(target, key);\n    switch (key) {\n      case 'arrayBuffer':\n      case 'blob':\n      case 'formData':\n      case 'json':\n      case 'text':\n        return () => {\n          this.item.responseType = key.toLowerCase();\n          // @ts-ignore\n          return value.apply(target).then(resp => {\n            this.item.response = (0, utils_js_1.getStringResponseByType)(this.item.responseType, resp);\n            return resp;\n          });\n        };\n    }\n    if (typeof value === 'function') {\n      return value.bind(target);\n    } else {\n      return value;\n    }\n  }\n  mockReader() {\n    let readerReceivedValue;\n    if (!this.resp.body) {\n      // some browsers do not return `body` in some cases, like `OPTIONS` method\n      return;\n    }\n    if (typeof this.resp.body.getReader !== 'function') {\n      return;\n    }\n    const _getReader = this.resp.body.getReader;\n    // @ts-ignore\n    this.resp.body.getReader = () => {\n      const reader = _getReader.apply(this.resp.body);\n      // when readyState is already 4,\n      // it's not a chunked stream, or it had already been read.\n      // so should not update status.\n      if (this.item.readyState === networkMessage_js_1.RequestState.DONE) {\n        return reader;\n      }\n      const _read = reader.read;\n      const _cancel = reader.cancel;\n      this.item.responseType = 'arraybuffer';\n      // @ts-ignore\n      reader.read = () => {\n        return _read.apply(reader).then(result => {\n          if (!readerReceivedValue) {\n            // @ts-ignore\n            readerReceivedValue = new Uint8Array(result.value);\n          } else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const newValue = new Uint8Array(readerReceivedValue.length + result.value.length);\n            newValue.set(readerReceivedValue);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            newValue.set(result.value, readerReceivedValue.length);\n            readerReceivedValue = newValue;\n          }\n          this.item.endTime = performance.now();\n          this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n          this.item.readyState = result.done ? 4 : 3;\n          this.item.statusText = result.done ? String(this.item.status) : 'Loading';\n          this.item.responseSize = readerReceivedValue.length;\n          this.item.responseSizeText = (0, utils_js_1.formatByteSize)(this.item.responseSize);\n          if (result.done) {\n            this.item.response = (0, utils_js_1.getStringResponseByType)(this.item.responseType, readerReceivedValue);\n          }\n          return result;\n        });\n      };\n      reader.cancel = (...args) => {\n        this.item.cancelState = 2;\n        this.item.statusText = 'Cancel';\n        this.item.endTime = performance.now();\n        this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n        this.item.response = (0, utils_js_1.getStringResponseByType)(this.item.responseType, readerReceivedValue);\n        return _cancel.apply(reader, args);\n      };\n      return reader;\n    };\n  }\n}\nexports.ResponseProxyHandler = ResponseProxyHandler;\nclass FetchProxyHandler {\n  constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n    this.ignoredHeaders = ignoredHeaders;\n    this.setSessionTokenHeader = setSessionTokenHeader;\n    this.sanitize = sanitize;\n    this.sendMessage = sendMessage;\n    this.isServiceUrl = isServiceUrl;\n    this.tokenUrlMatcher = tokenUrlMatcher;\n  }\n  apply(target, _, argsList) {\n    const input = argsList[0];\n    const init = argsList[1];\n    if (!input ||\n    // @ts-ignore\n    typeof input !== 'string' && !(input === null || input === void 0 ? void 0 : input.url)) {\n      return target.apply(window, argsList);\n    }\n    const isORUrl = input instanceof URL || typeof input === 'string' ? this.isServiceUrl(String(input)) : this.isServiceUrl(String(input.url));\n    if (isORUrl) {\n      return target.apply(window, argsList);\n    }\n    const item = new networkMessage_js_1.default(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);\n    this.beforeFetch(item, input, init);\n    this.setSessionTokenHeader((name, value) => {\n      if (this.tokenUrlMatcher !== undefined) {\n        if (!this.tokenUrlMatcher(item.url)) {\n          return;\n        }\n      }\n      if (argsList[1] === undefined && argsList[0] instanceof Request) {\n        return argsList[0].headers.append(name, value);\n      } else {\n        if (!argsList[1]) argsList[1] = {};\n        if (argsList[1].headers === undefined) {\n          argsList[1] = Object.assign(Object.assign({}, argsList[1]), {\n            headers: {}\n          });\n        }\n        if (argsList[1].headers instanceof Headers) {\n          argsList[1].headers.append(name, value);\n        } else if (Array.isArray(argsList[1].headers)) {\n          argsList[1].headers.push([name, value]);\n        } else {\n          // @ts-ignore\n          argsList[1].headers[name] = value;\n        }\n      }\n    });\n    return target.apply(window, argsList).then(this.afterFetch(item)).catch(e => {\n      // mock finally\n      item.endTime = performance.now();\n      item.duration = item.endTime - (item.startTime || item.endTime);\n      throw e;\n    });\n  }\n  beforeFetch(item, input, init) {\n    let url,\n      method = 'GET',\n      requestHeader = {};\n    // handle `input` content\n    if (typeof input === 'string') {\n      // when `input` is a string\n      method = (init === null || init === void 0 ? void 0 : init.method) || 'GET';\n      url = (0, utils_js_1.getURL)(input);\n      requestHeader = (init === null || init === void 0 ? void 0 : init.headers) || {};\n    } else {\n      // when `input` is a `Request` object\n      method = input.method || 'GET';\n      url = (0, utils_js_1.getURL)(input.url);\n      requestHeader = input.headers;\n    }\n    item.method = method;\n    item.requestType = 'fetch';\n    item.requestHeader = requestHeader;\n    item.url = url.toString();\n    item.name = (url.pathname.split('/').pop() || '') + url.search;\n    item.status = 0;\n    item.statusText = 'Pending';\n    item.readyState = 1;\n    if (!item.startTime) {\n      // UNSENT\n      item.startTime = performance.now();\n    }\n    if (Object.prototype.toString.call(requestHeader) === '[object Headers]') {\n      item.requestHeader = {};\n      for (const [key, value] of requestHeader) {\n        item.requestHeader[key] = value;\n      }\n    } else {\n      item.requestHeader = requestHeader;\n    }\n    // save GET data\n    if (url.search && url.searchParams) {\n      item.getData = {};\n      for (const [key, value] of url.searchParams) {\n        item.getData[key] = value;\n      }\n    }\n    // save POST data\n    if (init === null || init === void 0 ? void 0 : init.body) {\n      item.requestData = (0, utils_js_1.genStringBody)(init.body);\n    }\n  }\n  afterFetch(item) {\n    return resp => {\n      item.endTime = performance.now();\n      item.duration = item.endTime - (item.startTime || item.endTime);\n      item.status = resp.status;\n      item.statusText = String(resp.status);\n      let isChunked = false;\n      item.header = {};\n      for (const [key, value] of resp.headers) {\n        item.header[key] = value;\n        isChunked = value.toLowerCase().indexOf('chunked') > -1 ? true : isChunked;\n      }\n      if (isChunked) {\n        // when `transfer-encoding` is chunked, the response is a stream which is under loading,\n        // so the `readyState` should be 3 (Loading),\n        // and the response should NOT be `clone()` which will affect stream reading.\n        item.readyState = 3;\n      } else {\n        // Otherwise, not chunked, the response is not a stream,\n        // so it's completed and can be cloned for `text()` calling.\n        item.readyState = 4;\n        void this.handleResponseBody(resp.clone(), item).then(responseValue => {\n          item.responseSize = typeof responseValue === 'string' ? responseValue.length : responseValue.byteLength;\n          item.responseSizeText = (0, utils_js_1.formatByteSize)(item.responseSize);\n          item.response = (0, utils_js_1.getStringResponseByType)(item.responseType, responseValue);\n          this.sendMessage(item.getMessage());\n        });\n      }\n      return new Proxy(resp, new ResponseProxyHandler(resp, item));\n    };\n  }\n  handleResponseBody(resp, item) {\n    // parse response body by Content-Type\n    const contentType = resp.headers.get('content-type');\n    if (contentType && contentType.includes('application/json')) {\n      item.responseType = 'json';\n      return resp.text();\n    } else if (contentType && (contentType.includes('text/html') || contentType.includes('text/plain'))) {\n      item.responseType = 'text';\n      return resp.text();\n    } else {\n      item.responseType = 'arraybuffer';\n      return resp.arrayBuffer();\n    }\n  }\n}\nexports.FetchProxyHandler = FetchProxyHandler;\nclass FetchProxy {\n  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n    return new Proxy(fetch, new FetchProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));\n  }\n}\nexports.default = FetchProxy;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","FetchProxyHandler","ResponseProxyHandler","networkMessage_js_1","require","utils_js_1","constructor","resp","item","mockReader","set","target","key","Reflect","responseType","toLowerCase","apply","then","response","getStringResponseByType","bind","readerReceivedValue","body","getReader","_getReader","reader","readyState","RequestState","DONE","_read","read","_cancel","cancel","Uint8Array","newValue","length","endTime","performance","now","duration","startTime","done","statusText","String","status","responseSize","responseSizeText","formatByteSize","args","cancelState","ignoredHeaders","setSessionTokenHeader","sanitize","sendMessage","isServiceUrl","tokenUrlMatcher","_","argsList","input","init","url","window","isORUrl","URL","default","beforeFetch","name","Request","headers","append","assign","Headers","Array","isArray","push","afterFetch","catch","e","method","requestHeader","getURL","requestType","toString","pathname","split","pop","search","searchParams","getData","requestData","genStringBody","isChunked","header","indexOf","handleResponseBody","clone","responseValue","byteLength","getMessage","Proxy","contentType","includes","text","arrayBuffer","FetchProxy","fetch"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/cjs/modules/Network/fetchProxy.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchProxyHandler = exports.ResponseProxyHandler = void 0;\n/**\n * I took inspiration in few stack exchange posts\n * and Tencent vConsole library (MIT)\n * by wrapping the XMLHttpRequest object in a Proxy\n * we can intercept the network requests\n * in not-so-hacky way\n * */\nconst networkMessage_js_1 = __importStar(require(\"./networkMessage.js\"));\nconst utils_js_1 = require(\"./utils.js\");\nclass ResponseProxyHandler {\n    constructor(resp, item) {\n        this.resp = resp;\n        this.item = item;\n        this.mockReader();\n    }\n    set(target, key, value) {\n        return Reflect.set(target, key, value);\n    }\n    get(target, key) {\n        const value = Reflect.get(target, key);\n        switch (key) {\n            case 'arrayBuffer':\n            case 'blob':\n            case 'formData':\n            case 'json':\n            case 'text':\n                return () => {\n                    this.item.responseType = key.toLowerCase();\n                    // @ts-ignore\n                    return value.apply(target).then((resp) => {\n                        this.item.response = (0, utils_js_1.getStringResponseByType)(this.item.responseType, resp);\n                        return resp;\n                    });\n                };\n        }\n        if (typeof value === 'function') {\n            return value.bind(target);\n        }\n        else {\n            return value;\n        }\n    }\n    mockReader() {\n        let readerReceivedValue;\n        if (!this.resp.body) {\n            // some browsers do not return `body` in some cases, like `OPTIONS` method\n            return;\n        }\n        if (typeof this.resp.body.getReader !== 'function') {\n            return;\n        }\n        const _getReader = this.resp.body.getReader;\n        // @ts-ignore\n        this.resp.body.getReader = () => {\n            const reader = _getReader.apply(this.resp.body);\n            // when readyState is already 4,\n            // it's not a chunked stream, or it had already been read.\n            // so should not update status.\n            if (this.item.readyState === networkMessage_js_1.RequestState.DONE) {\n                return reader;\n            }\n            const _read = reader.read;\n            const _cancel = reader.cancel;\n            this.item.responseType = 'arraybuffer';\n            // @ts-ignore\n            reader.read = () => {\n                return _read.apply(reader).then((result) => {\n                    if (!readerReceivedValue) {\n                        // @ts-ignore\n                        readerReceivedValue = new Uint8Array(result.value);\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        const newValue = new Uint8Array(readerReceivedValue.length + result.value.length);\n                        newValue.set(readerReceivedValue);\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        newValue.set(result.value, readerReceivedValue.length);\n                        readerReceivedValue = newValue;\n                    }\n                    this.item.endTime = performance.now();\n                    this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n                    this.item.readyState = result.done ? 4 : 3;\n                    this.item.statusText = result.done ? String(this.item.status) : 'Loading';\n                    this.item.responseSize = readerReceivedValue.length;\n                    this.item.responseSizeText = (0, utils_js_1.formatByteSize)(this.item.responseSize);\n                    if (result.done) {\n                        this.item.response = (0, utils_js_1.getStringResponseByType)(this.item.responseType, readerReceivedValue);\n                    }\n                    return result;\n                });\n            };\n            reader.cancel = (...args) => {\n                this.item.cancelState = 2;\n                this.item.statusText = 'Cancel';\n                this.item.endTime = performance.now();\n                this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n                this.item.response = (0, utils_js_1.getStringResponseByType)(this.item.responseType, readerReceivedValue);\n                return _cancel.apply(reader, args);\n            };\n            return reader;\n        };\n    }\n}\nexports.ResponseProxyHandler = ResponseProxyHandler;\nclass FetchProxyHandler {\n    constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n        this.ignoredHeaders = ignoredHeaders;\n        this.setSessionTokenHeader = setSessionTokenHeader;\n        this.sanitize = sanitize;\n        this.sendMessage = sendMessage;\n        this.isServiceUrl = isServiceUrl;\n        this.tokenUrlMatcher = tokenUrlMatcher;\n    }\n    apply(target, _, argsList) {\n        const input = argsList[0];\n        const init = argsList[1];\n        if (!input ||\n            // @ts-ignore\n            (typeof input !== 'string' && !(input === null || input === void 0 ? void 0 : input.url))) {\n            return target.apply(window, argsList);\n        }\n        const isORUrl = input instanceof URL || typeof input === 'string'\n            ? this.isServiceUrl(String(input))\n            : this.isServiceUrl(String(input.url));\n        if (isORUrl) {\n            return target.apply(window, argsList);\n        }\n        const item = new networkMessage_js_1.default(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);\n        this.beforeFetch(item, input, init);\n        this.setSessionTokenHeader((name, value) => {\n            if (this.tokenUrlMatcher !== undefined) {\n                if (!this.tokenUrlMatcher(item.url)) {\n                    return;\n                }\n            }\n            if (argsList[1] === undefined && argsList[0] instanceof Request) {\n                return argsList[0].headers.append(name, value);\n            }\n            else {\n                if (!argsList[1])\n                    argsList[1] = {};\n                if (argsList[1].headers === undefined) {\n                    argsList[1] = Object.assign(Object.assign({}, argsList[1]), { headers: {} });\n                }\n                if (argsList[1].headers instanceof Headers) {\n                    argsList[1].headers.append(name, value);\n                }\n                else if (Array.isArray(argsList[1].headers)) {\n                    argsList[1].headers.push([name, value]);\n                }\n                else {\n                    // @ts-ignore\n                    argsList[1].headers[name] = value;\n                }\n            }\n        });\n        return target.apply(window, argsList)\n            .then(this.afterFetch(item))\n            .catch((e) => {\n            // mock finally\n            item.endTime = performance.now();\n            item.duration = item.endTime - (item.startTime || item.endTime);\n            throw e;\n        });\n    }\n    beforeFetch(item, input, init) {\n        let url, method = 'GET', requestHeader = {};\n        // handle `input` content\n        if (typeof input === 'string') {\n            // when `input` is a string\n            method = (init === null || init === void 0 ? void 0 : init.method) || 'GET';\n            url = (0, utils_js_1.getURL)(input);\n            requestHeader = (init === null || init === void 0 ? void 0 : init.headers) || {};\n        }\n        else {\n            // when `input` is a `Request` object\n            method = input.method || 'GET';\n            url = (0, utils_js_1.getURL)(input.url);\n            requestHeader = input.headers;\n        }\n        item.method = method;\n        item.requestType = 'fetch';\n        item.requestHeader = requestHeader;\n        item.url = url.toString();\n        item.name = (url.pathname.split('/').pop() || '') + url.search;\n        item.status = 0;\n        item.statusText = 'Pending';\n        item.readyState = 1;\n        if (!item.startTime) {\n            // UNSENT\n            item.startTime = performance.now();\n        }\n        if (Object.prototype.toString.call(requestHeader) === '[object Headers]') {\n            item.requestHeader = {};\n            for (const [key, value] of requestHeader) {\n                item.requestHeader[key] = value;\n            }\n        }\n        else {\n            item.requestHeader = requestHeader;\n        }\n        // save GET data\n        if (url.search && url.searchParams) {\n            item.getData = {};\n            for (const [key, value] of url.searchParams) {\n                item.getData[key] = value;\n            }\n        }\n        // save POST data\n        if (init === null || init === void 0 ? void 0 : init.body) {\n            item.requestData = (0, utils_js_1.genStringBody)(init.body);\n        }\n    }\n    afterFetch(item) {\n        return (resp) => {\n            item.endTime = performance.now();\n            item.duration = item.endTime - (item.startTime || item.endTime);\n            item.status = resp.status;\n            item.statusText = String(resp.status);\n            let isChunked = false;\n            item.header = {};\n            for (const [key, value] of resp.headers) {\n                item.header[key] = value;\n                isChunked = value.toLowerCase().indexOf('chunked') > -1 ? true : isChunked;\n            }\n            if (isChunked) {\n                // when `transfer-encoding` is chunked, the response is a stream which is under loading,\n                // so the `readyState` should be 3 (Loading),\n                // and the response should NOT be `clone()` which will affect stream reading.\n                item.readyState = 3;\n            }\n            else {\n                // Otherwise, not chunked, the response is not a stream,\n                // so it's completed and can be cloned for `text()` calling.\n                item.readyState = 4;\n                void this.handleResponseBody(resp.clone(), item).then((responseValue) => {\n                    item.responseSize =\n                        typeof responseValue === 'string' ? responseValue.length : responseValue.byteLength;\n                    item.responseSizeText = (0, utils_js_1.formatByteSize)(item.responseSize);\n                    item.response = (0, utils_js_1.getStringResponseByType)(item.responseType, responseValue);\n                    this.sendMessage(item.getMessage());\n                });\n            }\n            return new Proxy(resp, new ResponseProxyHandler(resp, item));\n        };\n    }\n    handleResponseBody(resp, item) {\n        // parse response body by Content-Type\n        const contentType = resp.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            item.responseType = 'json';\n            return resp.text();\n        }\n        else if (contentType &&\n            (contentType.includes('text/html') || contentType.includes('text/plain'))) {\n            item.responseType = 'text';\n            return resp.text();\n        }\n        else {\n            item.responseType = 'arraybuffer';\n            return resp.arrayBuffer();\n        }\n    }\n}\nexports.FetchProxyHandler = FetchProxyHandler;\nclass FetchProxy {\n    static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n        return new Proxy(fetch, new FetchProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));\n    }\n}\nexports.default = FetchProxy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}