{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst messages_gen_js_1 = require(\"../app/messages.gen.js\");\nconst utils_js_1 = require(\"../utils.js\");\nconst axiosSpy_js_1 = __importDefault(require(\"./axiosSpy.js\"));\nconst index_js_1 = __importDefault(require(\"./Network/index.js\"));\nfunction getXHRRequestDataObject(xhr) {\n  // @ts-ignore  this is 3x faster than using Map<XHR, XHRRequestData>\n  if (!xhr.__or_req_data__) {\n    // @ts-ignore\n    xhr.__or_req_data__ = {\n      body: undefined,\n      headers: {}\n    };\n  }\n  // @ts-ignore\n  return xhr.__or_req_data__;\n}\nfunction strMethod(method) {\n  return typeof method === 'string' ? method.toUpperCase() : 'GET';\n}\nfunction default_1(app, opts = {}) {\n  const options = Object.assign({\n    failuresOnly: false,\n    ignoreHeaders: ['cookie', 'set-cookie', 'authorization'],\n    capturePayload: false,\n    sessionTokenHeader: false,\n    captureInIframes: true,\n    axiosInstances: undefined,\n    useProxy: true\n  }, opts);\n  if (options.useProxy === false) {\n    app.debug.warn('Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true');\n  }\n  const ignoreHeaders = options.ignoreHeaders;\n  const isHIgnored = Array.isArray(ignoreHeaders) ? name => ignoreHeaders.includes(name) : () => ignoreHeaders;\n  const stHeader = options.sessionTokenHeader === true ? 'X-OpenReplay-SessionToken' : options.sessionTokenHeader;\n  function setSessionTokenHeader(setRequestHeader) {\n    if (stHeader) {\n      const sessionToken = app.getSessionToken();\n      if (sessionToken) {\n        app.safe(setRequestHeader)(stHeader, sessionToken);\n      }\n    }\n  }\n  function sanitize(reqResInfo) {\n    if (!options.capturePayload) {\n      // @ts-ignore\n      delete reqResInfo.request.body;\n      delete reqResInfo.response.body;\n    }\n    if (options.sanitizer) {\n      const resBody = reqResInfo.response.body;\n      if (typeof resBody === 'string') {\n        // Parse response in order to have handy view in sanitization function\n        try {\n          reqResInfo.response.body = JSON.parse(resBody);\n        } catch (_a) {}\n      }\n      return options.sanitizer(reqResInfo);\n    }\n    return reqResInfo;\n  }\n  function stringify(r) {\n    if (r && typeof r.body !== 'string') {\n      try {\n        r.body = JSON.stringify(r.body);\n      } catch (_a) {\n        r.body = '<unable to stringify>';\n        app.notify.warn(\"Openreplay fetch couldn't stringify body:\", r.body);\n      }\n    }\n    return JSON.stringify(r);\n  }\n  const patchWindow = context => {\n    /* ====== modern way ====== */\n    if (options.useProxy) {\n      return (0, index_js_1.default)(context, options.ignoreHeaders, setSessionTokenHeader, sanitize, message => app.send(message), url => app.isServiceURL(url), options.tokenUrlMatcher);\n    }\n    /* ====== Fetch ====== */\n    const origFetch = context.fetch.bind(context);\n    const trackFetch = (input, init = {}) => {\n      if (!(typeof input === 'string' || input instanceof URL) || app.isServiceURL(String(input))) {\n        return origFetch(input, init);\n      }\n      setSessionTokenHeader(function (name, value) {\n        if (init.headers === undefined) {\n          init.headers = {};\n        }\n        if (init.headers instanceof Headers) {\n          init.headers.append(name, value);\n        } else if (Array.isArray(init.headers)) {\n          init.headers.push([name, value]);\n        } else {\n          init.headers[name] = value;\n        }\n      });\n      const startTime = performance.now();\n      return origFetch(input, init).then(response => {\n        const duration = performance.now() - startTime;\n        if (options.failuresOnly && response.status < 400) {\n          return response;\n        }\n        const r = response.clone();\n        r.text().then(text => {\n          const reqHs = {};\n          const resHs = {};\n          if (ignoreHeaders !== true) {\n            // request headers\n            const writeReqHeader = ([n, v]) => {\n              if (!isHIgnored(n)) {\n                reqHs[n] = v;\n              }\n            };\n            if (init.headers instanceof Headers) {\n              init.headers.forEach((v, n) => writeReqHeader([n, v]));\n            } else if (Array.isArray(init.headers)) {\n              init.headers.forEach(writeReqHeader);\n            } else if (typeof init.headers === 'object') {\n              Object.entries(init.headers).forEach(writeReqHeader);\n            }\n            // response headers\n            r.headers.forEach((v, n) => {\n              if (!isHIgnored(n)) resHs[n] = v;\n            });\n          }\n          const method = strMethod(init.method);\n          const reqResInfo = sanitize({\n            url: String(input),\n            method,\n            status: r.status,\n            request: {\n              headers: reqHs,\n              // @ts-ignore\n              body: init.body || null\n            },\n            response: {\n              headers: resHs,\n              body: text\n            }\n          });\n          if (!reqResInfo) {\n            return;\n          }\n          app.send((0, messages_gen_js_1.NetworkRequest)('fetch', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), r.status, startTime + (0, utils_js_1.getTimeOrigin)(), duration, 0));\n        }).catch(e => app.debug.error('Could not process Fetch response:', e));\n        return response;\n      });\n    };\n    // @ts-ignore\n    context.fetch = trackFetch;\n    /* ====== <> ====== */\n    /* ====== XHR ====== */\n    const nativeOpen = context.XMLHttpRequest.prototype.open;\n    const nativeSetRequestHeader = context.XMLHttpRequest.prototype.setRequestHeader;\n    const nativeSend = context.XMLHttpRequest.prototype.send;\n    function trackXMLHttpReqOpen(initMethod, url) {\n      const xhr = this;\n      setSessionTokenHeader((name, value) => xhr.setRequestHeader(name, value));\n      let startTime = 0;\n      xhr.addEventListener('loadstart', e => {\n        startTime = e.timeStamp;\n      });\n      xhr.addEventListener('load', app.safe(e => {\n        const {\n          headers: reqHs,\n          body: reqBody\n        } = getXHRRequestDataObject(xhr);\n        const duration = startTime > 0 ? e.timeStamp - startTime : 0;\n        const hString = xhr.getAllResponseHeaders() || ''; // might be null (only if no response received though)\n        const headersArr = hString.trim().split(/[\\r\\n]+/);\n        const headerMap = {};\n        headersArr.forEach(function (line) {\n          const parts = line.split(': ');\n          const header = parts.shift();\n          if (!isHIgnored(header)) {\n            headerMap[header] = parts.join(': ');\n          }\n        });\n        const method = strMethod(initMethod);\n        const reqResInfo = sanitize({\n          url: String(url),\n          method,\n          status: xhr.status,\n          request: {\n            headers: reqHs,\n            // @ts-ignore\n            body: reqBody || null\n          },\n          response: {\n            headers: headerMap,\n            body: xhr.response\n          }\n        });\n        if (!reqResInfo) {\n          return;\n        }\n        app.send((0, messages_gen_js_1.NetworkRequest)('xhr', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), xhr.status, startTime + (0, utils_js_1.getTimeOrigin)(), duration, 0));\n      }));\n      //TODO: handle error (though it has no Error API nor any useful information)\n      //xhr.addEventListener('error', (e) => {})\n      return nativeOpen.apply(this, arguments);\n    }\n    function trackXHRSend(body) {\n      const rdo = getXHRRequestDataObject(this);\n      rdo.body = body;\n      // @ts-ignore ??? this -> XMLHttpRequest\n      return nativeSend.apply(this, arguments);\n    }\n    function trackSetReqHeader(name, value) {\n      if (!isHIgnored(name)) {\n        const rdo = getXHRRequestDataObject(this);\n        rdo.headers[name] = value;\n      }\n      return nativeSetRequestHeader.apply(this, arguments);\n    }\n    if (!options.axiosInstances) {\n      context.XMLHttpRequest.prototype.open = trackXMLHttpReqOpen;\n      context.XMLHttpRequest.prototype.send = trackXHRSend;\n      context.XMLHttpRequest.prototype.setRequestHeader = trackSetReqHeader;\n    }\n    /* ====== <> ====== */\n  };\n  patchWindow(window);\n  if (options.axiosInstances) {\n    options.axiosInstances.forEach(axiosInstance => {\n      (0, axiosSpy_js_1.default)(app, axiosInstance, options, sanitize, stringify);\n    });\n  }\n  if (options.captureInIframes) {\n    app.observer.attachContextCallback(app.safe(patchWindow));\n  }\n}\nexports.default = default_1;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","messages_gen_js_1","require","utils_js_1","axiosSpy_js_1","index_js_1","getXHRRequestDataObject","xhr","__or_req_data__","body","undefined","headers","strMethod","method","toUpperCase","default_1","app","opts","options","assign","failuresOnly","ignoreHeaders","capturePayload","sessionTokenHeader","captureInIframes","axiosInstances","useProxy","debug","warn","isHIgnored","Array","isArray","name","includes","stHeader","setSessionTokenHeader","setRequestHeader","sessionToken","getSessionToken","safe","sanitize","reqResInfo","request","response","sanitizer","resBody","JSON","parse","_a","stringify","r","notify","patchWindow","context","default","message","send","url","isServiceURL","tokenUrlMatcher","origFetch","fetch","bind","trackFetch","input","init","URL","String","Headers","append","push","startTime","performance","now","then","duration","status","clone","text","reqHs","resHs","writeReqHeader","n","v","forEach","entries","NetworkRequest","getTimeOrigin","catch","e","error","nativeOpen","XMLHttpRequest","prototype","open","nativeSetRequestHeader","nativeSend","trackXMLHttpReqOpen","initMethod","addEventListener","timeStamp","reqBody","hString","getAllResponseHeaders","headersArr","trim","split","headerMap","line","parts","header","shift","join","apply","arguments","trackXHRSend","rdo","trackSetReqHeader","window","axiosInstance","observer","attachContextCallback"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/cjs/modules/network.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst messages_gen_js_1 = require(\"../app/messages.gen.js\");\nconst utils_js_1 = require(\"../utils.js\");\nconst axiosSpy_js_1 = __importDefault(require(\"./axiosSpy.js\"));\nconst index_js_1 = __importDefault(require(\"./Network/index.js\"));\nfunction getXHRRequestDataObject(xhr) {\n    // @ts-ignore  this is 3x faster than using Map<XHR, XHRRequestData>\n    if (!xhr.__or_req_data__) {\n        // @ts-ignore\n        xhr.__or_req_data__ = { body: undefined, headers: {} };\n    }\n    // @ts-ignore\n    return xhr.__or_req_data__;\n}\nfunction strMethod(method) {\n    return typeof method === 'string' ? method.toUpperCase() : 'GET';\n}\nfunction default_1(app, opts = {}) {\n    const options = Object.assign({\n        failuresOnly: false,\n        ignoreHeaders: ['cookie', 'set-cookie', 'authorization'],\n        capturePayload: false,\n        sessionTokenHeader: false,\n        captureInIframes: true,\n        axiosInstances: undefined,\n        useProxy: true,\n    }, opts);\n    if (options.useProxy === false) {\n        app.debug.warn('Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true');\n    }\n    const ignoreHeaders = options.ignoreHeaders;\n    const isHIgnored = Array.isArray(ignoreHeaders)\n        ? (name) => ignoreHeaders.includes(name)\n        : () => ignoreHeaders;\n    const stHeader = options.sessionTokenHeader === true ? 'X-OpenReplay-SessionToken' : options.sessionTokenHeader;\n    function setSessionTokenHeader(setRequestHeader) {\n        if (stHeader) {\n            const sessionToken = app.getSessionToken();\n            if (sessionToken) {\n                app.safe(setRequestHeader)(stHeader, sessionToken);\n            }\n        }\n    }\n    function sanitize(reqResInfo) {\n        if (!options.capturePayload) {\n            // @ts-ignore\n            delete reqResInfo.request.body;\n            delete reqResInfo.response.body;\n        }\n        if (options.sanitizer) {\n            const resBody = reqResInfo.response.body;\n            if (typeof resBody === 'string') {\n                // Parse response in order to have handy view in sanitization function\n                try {\n                    reqResInfo.response.body = JSON.parse(resBody);\n                }\n                catch (_a) { }\n            }\n            return options.sanitizer(reqResInfo);\n        }\n        return reqResInfo;\n    }\n    function stringify(r) {\n        if (r && typeof r.body !== 'string') {\n            try {\n                r.body = JSON.stringify(r.body);\n            }\n            catch (_a) {\n                r.body = '<unable to stringify>';\n                app.notify.warn(\"Openreplay fetch couldn't stringify body:\", r.body);\n            }\n        }\n        return JSON.stringify(r);\n    }\n    const patchWindow = (context) => {\n        /* ====== modern way ====== */\n        if (options.useProxy) {\n            return (0, index_js_1.default)(context, options.ignoreHeaders, setSessionTokenHeader, sanitize, (message) => app.send(message), (url) => app.isServiceURL(url), options.tokenUrlMatcher);\n        }\n        /* ====== Fetch ====== */\n        const origFetch = context.fetch.bind(context);\n        const trackFetch = (input, init = {}) => {\n            if (!(typeof input === 'string' || input instanceof URL) || app.isServiceURL(String(input))) {\n                return origFetch(input, init);\n            }\n            setSessionTokenHeader(function (name, value) {\n                if (init.headers === undefined) {\n                    init.headers = {};\n                }\n                if (init.headers instanceof Headers) {\n                    init.headers.append(name, value);\n                }\n                else if (Array.isArray(init.headers)) {\n                    init.headers.push([name, value]);\n                }\n                else {\n                    init.headers[name] = value;\n                }\n            });\n            const startTime = performance.now();\n            return origFetch(input, init).then((response) => {\n                const duration = performance.now() - startTime;\n                if (options.failuresOnly && response.status < 400) {\n                    return response;\n                }\n                const r = response.clone();\n                r.text()\n                    .then((text) => {\n                    const reqHs = {};\n                    const resHs = {};\n                    if (ignoreHeaders !== true) {\n                        // request headers\n                        const writeReqHeader = ([n, v]) => {\n                            if (!isHIgnored(n)) {\n                                reqHs[n] = v;\n                            }\n                        };\n                        if (init.headers instanceof Headers) {\n                            init.headers.forEach((v, n) => writeReqHeader([n, v]));\n                        }\n                        else if (Array.isArray(init.headers)) {\n                            init.headers.forEach(writeReqHeader);\n                        }\n                        else if (typeof init.headers === 'object') {\n                            Object.entries(init.headers).forEach(writeReqHeader);\n                        }\n                        // response headers\n                        r.headers.forEach((v, n) => {\n                            if (!isHIgnored(n))\n                                resHs[n] = v;\n                        });\n                    }\n                    const method = strMethod(init.method);\n                    const reqResInfo = sanitize({\n                        url: String(input),\n                        method,\n                        status: r.status,\n                        request: {\n                            headers: reqHs,\n                            // @ts-ignore\n                            body: init.body || null,\n                        },\n                        response: {\n                            headers: resHs,\n                            body: text,\n                        },\n                    });\n                    if (!reqResInfo) {\n                        return;\n                    }\n                    app.send((0, messages_gen_js_1.NetworkRequest)('fetch', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), r.status, startTime + (0, utils_js_1.getTimeOrigin)(), duration, 0));\n                })\n                    .catch((e) => app.debug.error('Could not process Fetch response:', e));\n                return response;\n            });\n        };\n        // @ts-ignore\n        context.fetch = trackFetch;\n        /* ====== <> ====== */\n        /* ====== XHR ====== */\n        const nativeOpen = context.XMLHttpRequest.prototype.open;\n        const nativeSetRequestHeader = context.XMLHttpRequest.prototype.setRequestHeader;\n        const nativeSend = context.XMLHttpRequest.prototype.send;\n        function trackXMLHttpReqOpen(initMethod, url) {\n            const xhr = this;\n            setSessionTokenHeader((name, value) => xhr.setRequestHeader(name, value));\n            let startTime = 0;\n            xhr.addEventListener('loadstart', (e) => {\n                startTime = e.timeStamp;\n            });\n            xhr.addEventListener('load', app.safe((e) => {\n                const { headers: reqHs, body: reqBody } = getXHRRequestDataObject(xhr);\n                const duration = startTime > 0 ? e.timeStamp - startTime : 0;\n                const hString = xhr.getAllResponseHeaders() || ''; // might be null (only if no response received though)\n                const headersArr = hString.trim().split(/[\\r\\n]+/);\n                const headerMap = {};\n                headersArr.forEach(function (line) {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    if (!isHIgnored(header)) {\n                        headerMap[header] = parts.join(': ');\n                    }\n                });\n                const method = strMethod(initMethod);\n                const reqResInfo = sanitize({\n                    url: String(url),\n                    method,\n                    status: xhr.status,\n                    request: {\n                        headers: reqHs,\n                        // @ts-ignore\n                        body: reqBody || null,\n                    },\n                    response: {\n                        headers: headerMap,\n                        body: xhr.response,\n                    },\n                });\n                if (!reqResInfo) {\n                    return;\n                }\n                app.send((0, messages_gen_js_1.NetworkRequest)('xhr', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), xhr.status, startTime + (0, utils_js_1.getTimeOrigin)(), duration, 0));\n            }));\n            //TODO: handle error (though it has no Error API nor any useful information)\n            //xhr.addEventListener('error', (e) => {})\n            return nativeOpen.apply(this, arguments);\n        }\n        function trackXHRSend(body) {\n            const rdo = getXHRRequestDataObject(this);\n            rdo.body = body;\n            // @ts-ignore ??? this -> XMLHttpRequest\n            return nativeSend.apply(this, arguments);\n        }\n        function trackSetReqHeader(name, value) {\n            if (!isHIgnored(name)) {\n                const rdo = getXHRRequestDataObject(this);\n                rdo.headers[name] = value;\n            }\n            return nativeSetRequestHeader.apply(this, arguments);\n        }\n        if (!options.axiosInstances) {\n            context.XMLHttpRequest.prototype.open = trackXMLHttpReqOpen;\n            context.XMLHttpRequest.prototype.send = trackXHRSend;\n            context.XMLHttpRequest.prototype.setRequestHeader = trackSetReqHeader;\n        }\n        /* ====== <> ====== */\n    };\n    patchWindow(window);\n    if (options.axiosInstances) {\n        options.axiosInstances.forEach((axiosInstance) => {\n            (0, axiosSpy_js_1.default)(app, axiosInstance, options, sanitize, stringify);\n        });\n    }\n    if (options.captureInIframes) {\n        app.observer.attachContextCallback(app.safe(patchWindow));\n    }\n}\nexports.default = default_1;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}