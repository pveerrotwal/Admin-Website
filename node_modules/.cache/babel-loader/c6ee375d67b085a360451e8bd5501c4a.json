{"ast":null,"code":"import { createMutationObserver } from '../../utils.js';\nimport { RemoveNodeAttribute, SetNodeAttributeURLBased, SetCSSDataURLBased, SetNodeData, CreateTextNode, CreateElementNode, MoveNode, RemoveNode, UnbindNodes } from '../messages.gen.js';\nimport { isRootNode, isTextNode, isElementNode, isSVGElement, hasTag, isCommentNode } from '../guards.js';\nfunction isIgnored(node) {\n  if (isCommentNode(node)) {\n    return true;\n  }\n  if (isTextNode(node)) {\n    return false;\n  }\n  if (!isElementNode(node)) {\n    return true;\n  }\n  const tag = node.tagName.toUpperCase();\n  if (tag === 'LINK') {\n    const rel = node.getAttribute('rel');\n    const as = node.getAttribute('as');\n    return !((rel === null || rel === void 0 ? void 0 : rel.includes('stylesheet')) || as === 'style' || as === 'font');\n  }\n  return tag === 'SCRIPT' || tag === 'NOSCRIPT' || tag === 'META' || tag === 'TITLE' || tag === 'BASE';\n}\nfunction isObservable(node) {\n  if (isRootNode(node)) {\n    return true;\n  }\n  return !isIgnored(node);\n}\n/*\n  TODO:\n    - fix unbinding logic + send all removals first (ensure sequence is correct)\n    - use document as a 0-node in the upper context (should be updated in player at first)\n*/\nvar RecentsType;\n(function (RecentsType) {\n  RecentsType[RecentsType[\"New\"] = 0] = \"New\";\n  RecentsType[RecentsType[\"Removed\"] = 1] = \"Removed\";\n  RecentsType[RecentsType[\"Changed\"] = 2] = \"Changed\";\n})(RecentsType || (RecentsType = {}));\nexport default class Observer {\n  constructor(app, isTopContext = false) {\n    this.app = app;\n    this.isTopContext = isTopContext;\n    this.commited = [];\n    this.recents = new Map();\n    this.indexes = [];\n    this.attributesMap = new Map();\n    this.textSet = new Set();\n    this.observer = createMutationObserver(this.app.safe(mutations => {\n      for (const mutation of mutations) {\n        // mutations order is sequential\n        const target = mutation.target;\n        const type = mutation.type;\n        if (!isObservable(target)) {\n          continue;\n        }\n        if (type === 'childList') {\n          for (let i = 0; i < mutation.removedNodes.length; i++) {\n            // Should be the same as bindTree(mutation.removedNodes[i]), but logic needs to be be untied\n            if (isObservable(mutation.removedNodes[i])) {\n              this.bindNode(mutation.removedNodes[i]);\n            }\n          }\n          for (let i = 0; i < mutation.addedNodes.length; i++) {\n            this.bindTree(mutation.addedNodes[i]);\n          }\n          continue;\n        }\n        const id = this.app.nodes.getID(target);\n        if (id === undefined) {\n          continue;\n        }\n        if (!this.recents.has(id)) {\n          this.recents.set(id, RecentsType.Changed); // TODO only when altered\n        }\n        if (type === 'attributes') {\n          const name = mutation.attributeName;\n          if (name === null) {\n            continue;\n          }\n          let attr = this.attributesMap.get(id);\n          if (attr === undefined) {\n            this.attributesMap.set(id, attr = new Set());\n          }\n          attr.add(name);\n          continue;\n        }\n        if (type === 'characterData') {\n          this.textSet.add(id);\n          continue;\n        }\n      }\n      this.commitNodes();\n    }));\n  }\n  clear() {\n    this.commited.length = 0;\n    this.recents.clear();\n    this.indexes.length = 1;\n    this.attributesMap.clear();\n    this.textSet.clear();\n  }\n  sendNodeAttribute(id, node, name, value) {\n    if (isSVGElement(node)) {\n      if (name.substr(0, 6) === 'xlink:') {\n        name = name.substr(6);\n      }\n      if (value === null) {\n        this.app.send(RemoveNodeAttribute(id, name));\n      } else if (name === 'href') {\n        if (value.length > 1e5) {\n          value = '';\n        }\n        this.app.send(SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n      } else {\n        this.app.attributeSender.sendSetAttribute(id, name, value);\n      }\n      return;\n    }\n    if (name === 'src' || name === 'srcset' || name === 'integrity' || name === 'crossorigin' || name === 'autocomplete' || name.substr(0, 2) === 'on') {\n      return;\n    }\n    if (name === 'value' && hasTag(node, 'input') && node.type !== 'button' && node.type !== 'reset' && node.type !== 'submit') {\n      return;\n    }\n    if (value === null) {\n      this.app.send(RemoveNodeAttribute(id, name));\n      return;\n    }\n    if (name === 'style' || name === 'href' && hasTag(node, 'link')) {\n      this.app.send(SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n      return;\n    }\n    if (name === 'href' || value.length > 1e5) {\n      value = '';\n    }\n    this.app.attributeSender.sendSetAttribute(id, name, value);\n  }\n  sendNodeData(id, parentElement, data) {\n    if (hasTag(parentElement, 'style')) {\n      this.app.send(SetCSSDataURLBased(id, data, this.app.getBaseHref()));\n      return;\n    }\n    data = this.app.sanitizer.sanitize(id, data);\n    this.app.send(SetNodeData(id, data));\n  }\n  bindNode(node) {\n    const [id, isNew] = this.app.nodes.registerNode(node);\n    if (isNew) {\n      this.recents.set(id, RecentsType.New);\n    } else if (this.recents.get(id) !== RecentsType.New) {\n      this.recents.set(id, RecentsType.Removed);\n    }\n  }\n  bindTree(node) {\n    if (!isObservable(node)) {\n      return;\n    }\n    this.bindNode(node);\n    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {\n      acceptNode: node => isIgnored(node) || this.app.nodes.getID(node) !== undefined ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n    },\n    // @ts-ignore\n    false);\n    while (walker.nextNode()) {\n      this.bindNode(walker.currentNode);\n    }\n  }\n  unbindTree(node) {\n    const id = this.app.nodes.unregisterNode(node);\n    if (id !== undefined && this.recents.get(id) === RecentsType.Removed) {\n      // Sending RemoveNode only for parent to maintain\n      this.app.send(RemoveNode(id));\n      // Unregistering all the children in order to clear the memory\n      const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {\n        acceptNode: node => isIgnored(node) || this.app.nodes.getID(node) === undefined ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n      },\n      // @ts-ignore\n      false);\n      let removed = 0;\n      const totalBeforeRemove = this.app.nodes.getNodeCount();\n      while (walker.nextNode()) {\n        removed += 1;\n        this.app.nodes.unregisterNode(walker.currentNode);\n      }\n      const removedPercent = Math.floor(removed / totalBeforeRemove * 100);\n      if (removedPercent > 30) {\n        this.app.send(UnbindNodes(removedPercent));\n      }\n    }\n  }\n  // A top-consumption function on the infinite lists test. (~1% of performance resources)\n  _commitNode(id, node) {\n    if (isRootNode(node)) {\n      return true;\n    }\n    const parent = node.parentNode;\n    let parentID;\n    // Disable parent check for the upper context HTMLHtmlElement, because it is root there... (before)\n    // TODO: get rid of \"special\" cases (there is an issue with CreateDocument altered behaviour though)\n    // TODO: Clean the logic (though now it workd fine)\n    if (!hasTag(node, 'html') || !this.isTopContext) {\n      if (parent === null) {\n        // Sometimes one observation contains attribute mutations for the removimg node, which gets ignored here.\n        // That shouldn't affect the visual rendering ( should it? maybe when transition applied? )\n        this.unbindTree(node);\n        return false;\n      }\n      parentID = this.app.nodes.getID(parent);\n      if (parentID === undefined) {\n        this.unbindTree(node);\n        return false;\n      }\n      if (!this.commitNode(parentID)) {\n        this.unbindTree(node);\n        return false;\n      }\n      this.app.sanitizer.handleNode(id, parentID, node);\n      if (this.app.sanitizer.isHidden(parentID)) {\n        return false;\n      }\n    }\n    // From here parentID === undefined if node is top context HTML node\n    let sibling = node.previousSibling;\n    while (sibling !== null) {\n      const siblingID = this.app.nodes.getID(sibling);\n      if (siblingID !== undefined) {\n        this.commitNode(siblingID);\n        this.indexes[id] = this.indexes[siblingID] + 1;\n        break;\n      }\n      sibling = sibling.previousSibling;\n    }\n    if (sibling === null) {\n      this.indexes[id] = 0;\n    }\n    const recentsType = this.recents.get(id);\n    const isNew = recentsType === RecentsType.New;\n    const index = this.indexes[id];\n    if (index === undefined) {\n      throw 'commitNode: missing node index';\n    }\n    if (isNew) {\n      if (isElementNode(node)) {\n        let el = node;\n        if (parentID !== undefined) {\n          if (this.app.sanitizer.isHidden(id)) {\n            const width = el.clientWidth;\n            const height = el.clientHeight;\n            el = node.cloneNode();\n            el.style.width = `${width}px`;\n            el.style.height = `${height}px`;\n          }\n          this.app.send(CreateElementNode(id, parentID, index, el.tagName, isSVGElement(node)));\n        }\n        for (let i = 0; i < el.attributes.length; i++) {\n          const attr = el.attributes[i];\n          this.sendNodeAttribute(id, el, attr.nodeName, attr.value);\n        }\n      } else if (isTextNode(node)) {\n        // for text node id != 0, hence parentID !== undefined and parent is Element\n        this.app.send(CreateTextNode(id, parentID, index));\n        this.sendNodeData(id, parent, node.data);\n      }\n      return true;\n    }\n    if (recentsType === RecentsType.Removed && parentID !== undefined) {\n      this.app.send(MoveNode(id, parentID, index));\n    }\n    const attr = this.attributesMap.get(id);\n    if (attr !== undefined) {\n      if (!isElementNode(node)) {\n        throw 'commitNode: node is not an element';\n      }\n      for (const name of attr) {\n        this.sendNodeAttribute(id, node, name, node.getAttribute(name));\n      }\n    }\n    if (this.textSet.has(id)) {\n      if (!isTextNode(node)) {\n        throw 'commitNode: node is not a text';\n      }\n      // for text node id != 0, hence parent is Element\n      this.sendNodeData(id, parent, node.data);\n    }\n    return true;\n  }\n  commitNode(id) {\n    const node = this.app.nodes.getNode(id);\n    if (node === undefined) {\n      return false;\n    }\n    const cmt = this.commited[id];\n    if (cmt !== undefined) {\n      return cmt;\n    }\n    return this.commited[id] = this._commitNode(id, node);\n  }\n  commitNodes(isStart = false) {\n    let node;\n    this.recents.forEach((type, id) => {\n      this.commitNode(id);\n      if (type === RecentsType.New && (node = this.app.nodes.getNode(id))) {\n        this.app.nodes.callNodeCallbacks(node, isStart);\n      }\n    });\n    this.clear();\n  }\n  // ISSSUE (nodeToBinde should be the same as node in all cases. Look at the comment about 0-node at the beginning of the file.)\n  // TODO: use one observer instance for all iframes/shadowRoots (composition instiad of inheritance)\n  observeRoot(node, beforeCommit, nodeToBind = node) {\n    this.observer.observe(node, {\n      childList: true,\n      attributes: true,\n      characterData: true,\n      subtree: true,\n      attributeOldValue: false,\n      characterDataOldValue: false\n    });\n    this.bindTree(nodeToBind);\n    beforeCommit(this.app.nodes.getID(node));\n    this.commitNodes(true);\n  }\n  disconnect() {\n    this.observer.disconnect();\n    this.clear();\n  }\n}","map":{"version":3,"names":["createMutationObserver","RemoveNodeAttribute","SetNodeAttributeURLBased","SetCSSDataURLBased","SetNodeData","CreateTextNode","CreateElementNode","MoveNode","RemoveNode","UnbindNodes","isRootNode","isTextNode","isElementNode","isSVGElement","hasTag","isCommentNode","isIgnored","node","tag","tagName","toUpperCase","rel","getAttribute","as","includes","isObservable","RecentsType","Observer","constructor","app","isTopContext","commited","recents","Map","indexes","attributesMap","textSet","Set","observer","safe","mutations","mutation","target","type","i","removedNodes","length","bindNode","addedNodes","bindTree","id","nodes","getID","undefined","has","set","Changed","name","attributeName","attr","get","add","commitNodes","clear","sendNodeAttribute","value","substr","send","getBaseHref","attributeSender","sendSetAttribute","sendNodeData","parentElement","data","sanitizer","sanitize","isNew","registerNode","New","Removed","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","acceptNode","FILTER_REJECT","FILTER_ACCEPT","nextNode","currentNode","unbindTree","unregisterNode","removed","totalBeforeRemove","getNodeCount","removedPercent","Math","floor","_commitNode","parent","parentNode","parentID","commitNode","handleNode","isHidden","sibling","previousSibling","siblingID","recentsType","index","el","width","clientWidth","height","clientHeight","cloneNode","style","attributes","nodeName","getNode","cmt","isStart","forEach","callNodeCallbacks","observeRoot","beforeCommit","nodeToBind","observe","childList","characterData","subtree","attributeOldValue","characterDataOldValue","disconnect"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/lib/app/observer/observer.js"],"sourcesContent":["import { createMutationObserver } from '../../utils.js';\nimport { RemoveNodeAttribute, SetNodeAttributeURLBased, SetCSSDataURLBased, SetNodeData, CreateTextNode, CreateElementNode, MoveNode, RemoveNode, UnbindNodes, } from '../messages.gen.js';\nimport { isRootNode, isTextNode, isElementNode, isSVGElement, hasTag, isCommentNode, } from '../guards.js';\nfunction isIgnored(node) {\n    if (isCommentNode(node)) {\n        return true;\n    }\n    if (isTextNode(node)) {\n        return false;\n    }\n    if (!isElementNode(node)) {\n        return true;\n    }\n    const tag = node.tagName.toUpperCase();\n    if (tag === 'LINK') {\n        const rel = node.getAttribute('rel');\n        const as = node.getAttribute('as');\n        return !((rel === null || rel === void 0 ? void 0 : rel.includes('stylesheet')) || as === 'style' || as === 'font');\n    }\n    return (tag === 'SCRIPT' || tag === 'NOSCRIPT' || tag === 'META' || tag === 'TITLE' || tag === 'BASE');\n}\nfunction isObservable(node) {\n    if (isRootNode(node)) {\n        return true;\n    }\n    return !isIgnored(node);\n}\n/*\n  TODO:\n    - fix unbinding logic + send all removals first (ensure sequence is correct)\n    - use document as a 0-node in the upper context (should be updated in player at first)\n*/\nvar RecentsType;\n(function (RecentsType) {\n    RecentsType[RecentsType[\"New\"] = 0] = \"New\";\n    RecentsType[RecentsType[\"Removed\"] = 1] = \"Removed\";\n    RecentsType[RecentsType[\"Changed\"] = 2] = \"Changed\";\n})(RecentsType || (RecentsType = {}));\nexport default class Observer {\n    constructor(app, isTopContext = false) {\n        this.app = app;\n        this.isTopContext = isTopContext;\n        this.commited = [];\n        this.recents = new Map();\n        this.indexes = [];\n        this.attributesMap = new Map();\n        this.textSet = new Set();\n        this.observer = createMutationObserver(this.app.safe((mutations) => {\n            for (const mutation of mutations) {\n                // mutations order is sequential\n                const target = mutation.target;\n                const type = mutation.type;\n                if (!isObservable(target)) {\n                    continue;\n                }\n                if (type === 'childList') {\n                    for (let i = 0; i < mutation.removedNodes.length; i++) {\n                        // Should be the same as bindTree(mutation.removedNodes[i]), but logic needs to be be untied\n                        if (isObservable(mutation.removedNodes[i])) {\n                            this.bindNode(mutation.removedNodes[i]);\n                        }\n                    }\n                    for (let i = 0; i < mutation.addedNodes.length; i++) {\n                        this.bindTree(mutation.addedNodes[i]);\n                    }\n                    continue;\n                }\n                const id = this.app.nodes.getID(target);\n                if (id === undefined) {\n                    continue;\n                }\n                if (!this.recents.has(id)) {\n                    this.recents.set(id, RecentsType.Changed); // TODO only when altered\n                }\n                if (type === 'attributes') {\n                    const name = mutation.attributeName;\n                    if (name === null) {\n                        continue;\n                    }\n                    let attr = this.attributesMap.get(id);\n                    if (attr === undefined) {\n                        this.attributesMap.set(id, (attr = new Set()));\n                    }\n                    attr.add(name);\n                    continue;\n                }\n                if (type === 'characterData') {\n                    this.textSet.add(id);\n                    continue;\n                }\n            }\n            this.commitNodes();\n        }));\n    }\n    clear() {\n        this.commited.length = 0;\n        this.recents.clear();\n        this.indexes.length = 1;\n        this.attributesMap.clear();\n        this.textSet.clear();\n    }\n    sendNodeAttribute(id, node, name, value) {\n        if (isSVGElement(node)) {\n            if (name.substr(0, 6) === 'xlink:') {\n                name = name.substr(6);\n            }\n            if (value === null) {\n                this.app.send(RemoveNodeAttribute(id, name));\n            }\n            else if (name === 'href') {\n                if (value.length > 1e5) {\n                    value = '';\n                }\n                this.app.send(SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n            }\n            else {\n                this.app.attributeSender.sendSetAttribute(id, name, value);\n            }\n            return;\n        }\n        if (name === 'src' ||\n            name === 'srcset' ||\n            name === 'integrity' ||\n            name === 'crossorigin' ||\n            name === 'autocomplete' ||\n            name.substr(0, 2) === 'on') {\n            return;\n        }\n        if (name === 'value' &&\n            hasTag(node, 'input') &&\n            node.type !== 'button' &&\n            node.type !== 'reset' &&\n            node.type !== 'submit') {\n            return;\n        }\n        if (value === null) {\n            this.app.send(RemoveNodeAttribute(id, name));\n            return;\n        }\n        if (name === 'style' || (name === 'href' && hasTag(node, 'link'))) {\n            this.app.send(SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));\n            return;\n        }\n        if (name === 'href' || value.length > 1e5) {\n            value = '';\n        }\n        this.app.attributeSender.sendSetAttribute(id, name, value);\n    }\n    sendNodeData(id, parentElement, data) {\n        if (hasTag(parentElement, 'style')) {\n            this.app.send(SetCSSDataURLBased(id, data, this.app.getBaseHref()));\n            return;\n        }\n        data = this.app.sanitizer.sanitize(id, data);\n        this.app.send(SetNodeData(id, data));\n    }\n    bindNode(node) {\n        const [id, isNew] = this.app.nodes.registerNode(node);\n        if (isNew) {\n            this.recents.set(id, RecentsType.New);\n        }\n        else if (this.recents.get(id) !== RecentsType.New) {\n            this.recents.set(id, RecentsType.Removed);\n        }\n    }\n    bindTree(node) {\n        if (!isObservable(node)) {\n            return;\n        }\n        this.bindNode(node);\n        const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {\n            acceptNode: (node) => isIgnored(node) || this.app.nodes.getID(node) !== undefined\n                ? NodeFilter.FILTER_REJECT\n                : NodeFilter.FILTER_ACCEPT,\n        }, \n        // @ts-ignore\n        false);\n        while (walker.nextNode()) {\n            this.bindNode(walker.currentNode);\n        }\n    }\n    unbindTree(node) {\n        const id = this.app.nodes.unregisterNode(node);\n        if (id !== undefined && this.recents.get(id) === RecentsType.Removed) {\n            // Sending RemoveNode only for parent to maintain\n            this.app.send(RemoveNode(id));\n            // Unregistering all the children in order to clear the memory\n            const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {\n                acceptNode: (node) => isIgnored(node) || this.app.nodes.getID(node) === undefined\n                    ? NodeFilter.FILTER_REJECT\n                    : NodeFilter.FILTER_ACCEPT,\n            }, \n            // @ts-ignore\n            false);\n            let removed = 0;\n            const totalBeforeRemove = this.app.nodes.getNodeCount();\n            while (walker.nextNode()) {\n                removed += 1;\n                this.app.nodes.unregisterNode(walker.currentNode);\n            }\n            const removedPercent = Math.floor((removed / totalBeforeRemove) * 100);\n            if (removedPercent > 30) {\n                this.app.send(UnbindNodes(removedPercent));\n            }\n        }\n    }\n    // A top-consumption function on the infinite lists test. (~1% of performance resources)\n    _commitNode(id, node) {\n        if (isRootNode(node)) {\n            return true;\n        }\n        const parent = node.parentNode;\n        let parentID;\n        // Disable parent check for the upper context HTMLHtmlElement, because it is root there... (before)\n        // TODO: get rid of \"special\" cases (there is an issue with CreateDocument altered behaviour though)\n        // TODO: Clean the logic (though now it workd fine)\n        if (!hasTag(node, 'html') || !this.isTopContext) {\n            if (parent === null) {\n                // Sometimes one observation contains attribute mutations for the removimg node, which gets ignored here.\n                // That shouldn't affect the visual rendering ( should it? maybe when transition applied? )\n                this.unbindTree(node);\n                return false;\n            }\n            parentID = this.app.nodes.getID(parent);\n            if (parentID === undefined) {\n                this.unbindTree(node);\n                return false;\n            }\n            if (!this.commitNode(parentID)) {\n                this.unbindTree(node);\n                return false;\n            }\n            this.app.sanitizer.handleNode(id, parentID, node);\n            if (this.app.sanitizer.isHidden(parentID)) {\n                return false;\n            }\n        }\n        // From here parentID === undefined if node is top context HTML node\n        let sibling = node.previousSibling;\n        while (sibling !== null) {\n            const siblingID = this.app.nodes.getID(sibling);\n            if (siblingID !== undefined) {\n                this.commitNode(siblingID);\n                this.indexes[id] = this.indexes[siblingID] + 1;\n                break;\n            }\n            sibling = sibling.previousSibling;\n        }\n        if (sibling === null) {\n            this.indexes[id] = 0;\n        }\n        const recentsType = this.recents.get(id);\n        const isNew = recentsType === RecentsType.New;\n        const index = this.indexes[id];\n        if (index === undefined) {\n            throw 'commitNode: missing node index';\n        }\n        if (isNew) {\n            if (isElementNode(node)) {\n                let el = node;\n                if (parentID !== undefined) {\n                    if (this.app.sanitizer.isHidden(id)) {\n                        const width = el.clientWidth;\n                        const height = el.clientHeight;\n                        el = node.cloneNode();\n                        el.style.width = `${width}px`;\n                        el.style.height = `${height}px`;\n                    }\n                    this.app.send(CreateElementNode(id, parentID, index, el.tagName, isSVGElement(node)));\n                }\n                for (let i = 0; i < el.attributes.length; i++) {\n                    const attr = el.attributes[i];\n                    this.sendNodeAttribute(id, el, attr.nodeName, attr.value);\n                }\n            }\n            else if (isTextNode(node)) {\n                // for text node id != 0, hence parentID !== undefined and parent is Element\n                this.app.send(CreateTextNode(id, parentID, index));\n                this.sendNodeData(id, parent, node.data);\n            }\n            return true;\n        }\n        if (recentsType === RecentsType.Removed && parentID !== undefined) {\n            this.app.send(MoveNode(id, parentID, index));\n        }\n        const attr = this.attributesMap.get(id);\n        if (attr !== undefined) {\n            if (!isElementNode(node)) {\n                throw 'commitNode: node is not an element';\n            }\n            for (const name of attr) {\n                this.sendNodeAttribute(id, node, name, node.getAttribute(name));\n            }\n        }\n        if (this.textSet.has(id)) {\n            if (!isTextNode(node)) {\n                throw 'commitNode: node is not a text';\n            }\n            // for text node id != 0, hence parent is Element\n            this.sendNodeData(id, parent, node.data);\n        }\n        return true;\n    }\n    commitNode(id) {\n        const node = this.app.nodes.getNode(id);\n        if (node === undefined) {\n            return false;\n        }\n        const cmt = this.commited[id];\n        if (cmt !== undefined) {\n            return cmt;\n        }\n        return (this.commited[id] = this._commitNode(id, node));\n    }\n    commitNodes(isStart = false) {\n        let node;\n        this.recents.forEach((type, id) => {\n            this.commitNode(id);\n            if (type === RecentsType.New && (node = this.app.nodes.getNode(id))) {\n                this.app.nodes.callNodeCallbacks(node, isStart);\n            }\n        });\n        this.clear();\n    }\n    // ISSSUE (nodeToBinde should be the same as node in all cases. Look at the comment about 0-node at the beginning of the file.)\n    // TODO: use one observer instance for all iframes/shadowRoots (composition instiad of inheritance)\n    observeRoot(node, beforeCommit, nodeToBind = node) {\n        this.observer.observe(node, {\n            childList: true,\n            attributes: true,\n            characterData: true,\n            subtree: true,\n            attributeOldValue: false,\n            characterDataOldValue: false,\n        });\n        this.bindTree(nodeToBind);\n        beforeCommit(this.app.nodes.getID(node));\n        this.commitNodes(true);\n    }\n    disconnect() {\n        this.observer.disconnect();\n        this.clear();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}