{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_js_1 = require(\"../utils.js\");\nclass Nodes {\n  constructor(node_id) {\n    this.node_id = node_id;\n    this.nodes = [];\n    this.totalNodeAmount = 0;\n    this.nodeCallbacks = [];\n    this.elementListeners = new Map();\n    this.scanTree = cb => {\n      this.nodes.forEach(node => cb(node));\n    };\n  }\n  // Attached once per Tracker instance\n  attachNodeCallback(nodeCallback) {\n    this.nodeCallbacks.push(nodeCallback);\n  }\n  attachNodeListener(node, type, listener, useCapture = true) {\n    const id = this.getID(node);\n    if (id === undefined) {\n      return;\n    }\n    (0, utils_js_1.createEventListener)(node, type, listener, useCapture);\n    let listeners = this.elementListeners.get(id);\n    if (listeners === undefined) {\n      listeners = [];\n      this.elementListeners.set(id, listeners);\n    }\n    listeners.push([type, listener, useCapture]);\n  }\n  registerNode(node) {\n    let id = node[this.node_id];\n    const isNew = id === undefined;\n    if (isNew) {\n      this.totalNodeAmount++;\n      id = this.nodes.length;\n      this.nodes[id] = node;\n      node[this.node_id] = id;\n    }\n    return [id, isNew];\n  }\n  unregisterNode(node) {\n    const id = node[this.node_id];\n    if (id !== undefined) {\n      delete node[this.node_id];\n      delete this.nodes[id];\n      const listeners = this.elementListeners.get(id);\n      if (listeners !== undefined) {\n        this.elementListeners.delete(id);\n        listeners.forEach(listener => (0, utils_js_1.deleteEventListener)(node, listener[0], listener[1], listener[2]));\n      }\n      this.totalNodeAmount--;\n    }\n    return id;\n  }\n  cleanTree() {\n    // sadly we keep empty items in array here resulting in some memory still being used\n    // but its still better than keeping dead nodes or undef elements\n    // plus we keep our index positions for new/alive nodes\n    // performance test: 3ms for 30k nodes with 17k dead ones\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i];\n      if (node && !document.contains(node)) {\n        this.unregisterNode(node);\n      }\n    }\n  }\n  callNodeCallbacks(node, isStart) {\n    this.nodeCallbacks.forEach(cb => cb(node, isStart));\n  }\n  getID(node) {\n    if (!node) return undefined;\n    return node[this.node_id];\n  }\n  getNode(id) {\n    return this.nodes[id];\n  }\n  getNodeCount() {\n    return this.totalNodeAmount;\n  }\n  clear() {\n    for (let id = 0; id < this.nodes.length; id++) {\n      const node = this.nodes[id];\n      if (!node) {\n        continue;\n      }\n      this.unregisterNode(node);\n    }\n    this.nodes.length = 0;\n  }\n}\nexports.default = Nodes;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils_js_1","require","Nodes","constructor","node_id","nodes","totalNodeAmount","nodeCallbacks","elementListeners","Map","scanTree","cb","forEach","node","attachNodeCallback","nodeCallback","push","attachNodeListener","type","listener","useCapture","id","getID","undefined","createEventListener","listeners","get","set","registerNode","isNew","length","unregisterNode","delete","deleteEventListener","cleanTree","i","document","contains","callNodeCallbacks","isStart","getNode","getNodeCount","clear","default"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/cjs/app/nodes.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_js_1 = require(\"../utils.js\");\nclass Nodes {\n    constructor(node_id) {\n        this.node_id = node_id;\n        this.nodes = [];\n        this.totalNodeAmount = 0;\n        this.nodeCallbacks = [];\n        this.elementListeners = new Map();\n        this.scanTree = (cb) => {\n            this.nodes.forEach((node) => cb(node));\n        };\n    }\n    // Attached once per Tracker instance\n    attachNodeCallback(nodeCallback) {\n        this.nodeCallbacks.push(nodeCallback);\n    }\n    attachNodeListener(node, type, listener, useCapture = true) {\n        const id = this.getID(node);\n        if (id === undefined) {\n            return;\n        }\n        (0, utils_js_1.createEventListener)(node, type, listener, useCapture);\n        let listeners = this.elementListeners.get(id);\n        if (listeners === undefined) {\n            listeners = [];\n            this.elementListeners.set(id, listeners);\n        }\n        listeners.push([type, listener, useCapture]);\n    }\n    registerNode(node) {\n        let id = node[this.node_id];\n        const isNew = id === undefined;\n        if (isNew) {\n            this.totalNodeAmount++;\n            id = this.nodes.length;\n            this.nodes[id] = node;\n            node[this.node_id] = id;\n        }\n        return [id, isNew];\n    }\n    unregisterNode(node) {\n        const id = node[this.node_id];\n        if (id !== undefined) {\n            delete node[this.node_id];\n            delete this.nodes[id];\n            const listeners = this.elementListeners.get(id);\n            if (listeners !== undefined) {\n                this.elementListeners.delete(id);\n                listeners.forEach((listener) => (0, utils_js_1.deleteEventListener)(node, listener[0], listener[1], listener[2]));\n            }\n            this.totalNodeAmount--;\n        }\n        return id;\n    }\n    cleanTree() {\n        // sadly we keep empty items in array here resulting in some memory still being used\n        // but its still better than keeping dead nodes or undef elements\n        // plus we keep our index positions for new/alive nodes\n        // performance test: 3ms for 30k nodes with 17k dead ones\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (node && !document.contains(node)) {\n                this.unregisterNode(node);\n            }\n        }\n    }\n    callNodeCallbacks(node, isStart) {\n        this.nodeCallbacks.forEach((cb) => cb(node, isStart));\n    }\n    getID(node) {\n        if (!node)\n            return undefined;\n        return node[this.node_id];\n    }\n    getNode(id) {\n        return this.nodes[id];\n    }\n    getNodeCount() {\n        return this.totalNodeAmount;\n    }\n    clear() {\n        for (let id = 0; id < this.nodes.length; id++) {\n            const node = this.nodes[id];\n            if (!node) {\n                continue;\n            }\n            this.unregisterNode(node);\n        }\n        this.nodes.length = 0;\n    }\n}\nexports.default = Nodes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}