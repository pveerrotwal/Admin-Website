{"ast":null,"code":"import { hasTag } from '../app/guards.js';\nimport { isURL, getTimeOrigin } from '../utils.js';\nimport { ResourceTiming, PageLoadTiming, PageRenderTiming } from '../app/messages.gen.js';\nfunction getPaintBlocks(resources) {\n  const paintBlocks = [];\n  const elements = document.getElementsByTagName('*');\n  const styleURL = /url\\((\"[^\"]*\"|'[^']*'|[^)]*)\\)/i;\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    let src = '';\n    if (hasTag(element, 'img')) {\n      src = element.currentSrc || element.src;\n    }\n    if (!src) {\n      const backgroundImage = getComputedStyle(element).getPropertyValue('background-image');\n      if (backgroundImage) {\n        const matches = styleURL.exec(backgroundImage);\n        if (matches !== null) {\n          src = matches[1];\n          if (src.startsWith('\"') || src.startsWith(\"'\")) {\n            src = src.substr(1, src.length - 2);\n          }\n        }\n      }\n    }\n    if (!src) continue;\n    const time = src.substr(0, 10) === 'data:image' ? 0 : resources[src];\n    if (time === undefined) continue;\n    const rect = element.getBoundingClientRect();\n    const top = Math.max(rect.top, 0);\n    const left = Math.max(rect.left, 0);\n    const bottom = Math.min(rect.bottom, window.innerHeight || document.documentElement && document.documentElement.clientHeight || 0);\n    const right = Math.min(rect.right, window.innerWidth || document.documentElement && document.documentElement.clientWidth || 0);\n    if (bottom <= top || right <= left) continue;\n    const area = (bottom - top) * (right - left);\n    paintBlocks.push({\n      time,\n      area\n    });\n  }\n  return paintBlocks;\n}\nfunction calculateSpeedIndex(firstContentfulPaint, paintBlocks) {\n  let a = Math.max(document.documentElement && document.documentElement.clientWidth || 0, window.innerWidth || 0) * Math.max(document.documentElement && document.documentElement.clientHeight || 0, window.innerHeight || 0) / 10;\n  let s = a * firstContentfulPaint;\n  for (let i = 0; i < paintBlocks.length; i++) {\n    const {\n      time,\n      area\n    } = paintBlocks[i];\n    a += area;\n    s += area * (time > firstContentfulPaint ? time : firstContentfulPaint);\n  }\n  return a === 0 ? 0 : s / a;\n}\nexport default function (app, opts) {\n  const options = Object.assign({\n    captureResourceTimings: true,\n    capturePageLoadTimings: true,\n    capturePageRenderTimings: true,\n    excludedResourceUrls: []\n  }, opts);\n  if (!('PerformanceObserver' in window)) {\n    options.captureResourceTimings = false;\n  }\n  if (!options.captureResourceTimings) {\n    return;\n  } // Resources are necessary for all timings\n  let resources = {};\n  function resourceTiming(entry) {\n    var _a;\n    if (entry.duration < 0 || !isURL(entry.name) || app.isServiceURL(entry.name)) return;\n    if (resources !== null) {\n      resources[entry.name] = entry.startTime + entry.duration;\n    }\n    let shouldSkip = false;\n    (_a = options.excludedResourceUrls) === null || _a === void 0 ? void 0 : _a.forEach(url => {\n      if (entry.name.startsWith(url)) {\n        shouldSkip = true;\n        return;\n      }\n    });\n    if (shouldSkip) {\n      return;\n    }\n    app.send(ResourceTiming(entry.startTime + getTimeOrigin(), entry.duration, entry.responseStart && entry.startTime ? entry.responseStart - entry.startTime : 0, entry.transferSize > entry.encodedBodySize ? entry.transferSize - entry.encodedBodySize : 0, entry.encodedBodySize || 0, entry.decodedBodySize || 0, entry.name, entry.initiatorType, entry.transferSize,\n    // @ts-ignore\n    entry.responseStatus && entry.responseStatus === 304 || entry.transferSize === 0));\n  }\n  const observer = new PerformanceObserver(list => list.getEntries().forEach(resourceTiming));\n  let prevSessionID;\n  app.attachStartCallback(function ({\n    sessionID\n  }) {\n    if (sessionID !== prevSessionID) {\n      // Send past page resources on a newly started session\n      performance.getEntriesByType('resource').forEach(resourceTiming);\n      prevSessionID = sessionID;\n    }\n    observer.observe({\n      entryTypes: ['resource']\n    });\n  });\n  app.attachStopCallback(function () {\n    observer.disconnect();\n  });\n  let firstPaint = 0,\n    firstContentfulPaint = 0;\n  if (options.capturePageLoadTimings) {\n    let pageLoadTimingSent = false;\n    app.ticker.attach(() => {\n      if (pageLoadTimingSent) {\n        return;\n      }\n      if (firstPaint === 0 || firstContentfulPaint === 0) {\n        performance.getEntriesByType('paint').forEach(entry => {\n          const {\n            name,\n            startTime\n          } = entry;\n          switch (name) {\n            case 'first-paint':\n              firstPaint = startTime;\n              break;\n            case 'first-contentful-paint':\n              firstContentfulPaint = startTime;\n              break;\n          }\n        });\n      }\n      if (performance.timing.loadEventEnd || performance.now() > 30000) {\n        pageLoadTimingSent = true;\n        const {\n          // should be ok to use here, (https://github.com/mdn/content/issues/4713)\n          // since it is compared with the values obtained on the page load (before any possible sleep state)\n          // deprecated though\n          navigationStart,\n          requestStart,\n          responseStart,\n          responseEnd,\n          domContentLoadedEventStart,\n          domContentLoadedEventEnd,\n          loadEventStart,\n          loadEventEnd\n        } = performance.timing;\n        app.send(PageLoadTiming(requestStart - navigationStart || 0, responseStart - navigationStart || 0, responseEnd - navigationStart || 0, domContentLoadedEventStart - navigationStart || 0, domContentLoadedEventEnd - navigationStart || 0, loadEventStart - navigationStart || 0, loadEventEnd - navigationStart || 0, firstPaint, firstContentfulPaint));\n      }\n    }, 30);\n  }\n  if (options.capturePageRenderTimings) {\n    let visuallyComplete = 0,\n      interactiveWindowStartTime = 0,\n      interactiveWindowTickTime = 0,\n      paintBlocks = null;\n    let pageRenderTimingSent = false;\n    app.ticker.attach(() => {\n      if (pageRenderTimingSent) {\n        return;\n      }\n      const time = performance.now();\n      if (resources !== null) {\n        visuallyComplete = Math.max.apply(null, Object.keys(resources).map(k => resources[k]));\n        if (time - visuallyComplete > 1000) {\n          paintBlocks = getPaintBlocks(resources);\n          resources = null;\n        }\n      }\n      if (interactiveWindowTickTime !== null) {\n        if (time - interactiveWindowTickTime > 50) {\n          interactiveWindowStartTime = time;\n        }\n        interactiveWindowTickTime = time - interactiveWindowStartTime > 5000 ? null : time;\n      }\n      if (paintBlocks !== null && interactiveWindowTickTime === null || time > 30000) {\n        pageRenderTimingSent = true;\n        resources = null;\n        const speedIndex = paintBlocks === null ? 0 : calculateSpeedIndex(firstContentfulPaint || firstPaint, paintBlocks);\n        const {\n          domContentLoadedEventEnd,\n          navigationStart\n        } = performance.timing;\n        const timeToInteractive = interactiveWindowTickTime === null ? Math.max(interactiveWindowStartTime, firstContentfulPaint, domContentLoadedEventEnd - navigationStart || 0) : 0;\n        app.send(PageRenderTiming(speedIndex, firstContentfulPaint > visuallyComplete ? firstContentfulPaint : visuallyComplete, timeToInteractive));\n      }\n    });\n  }\n}","map":{"version":3,"names":["hasTag","isURL","getTimeOrigin","ResourceTiming","PageLoadTiming","PageRenderTiming","getPaintBlocks","resources","paintBlocks","elements","document","getElementsByTagName","styleURL","i","length","element","src","currentSrc","backgroundImage","getComputedStyle","getPropertyValue","matches","exec","startsWith","substr","time","undefined","rect","getBoundingClientRect","top","Math","max","left","bottom","min","window","innerHeight","documentElement","clientHeight","right","innerWidth","clientWidth","area","push","calculateSpeedIndex","firstContentfulPaint","a","s","app","opts","options","Object","assign","captureResourceTimings","capturePageLoadTimings","capturePageRenderTimings","excludedResourceUrls","resourceTiming","entry","_a","duration","name","isServiceURL","startTime","shouldSkip","forEach","url","send","responseStart","transferSize","encodedBodySize","decodedBodySize","initiatorType","responseStatus","observer","PerformanceObserver","list","getEntries","prevSessionID","attachStartCallback","sessionID","performance","getEntriesByType","observe","entryTypes","attachStopCallback","disconnect","firstPaint","pageLoadTimingSent","ticker","attach","timing","loadEventEnd","now","navigationStart","requestStart","responseEnd","domContentLoadedEventStart","domContentLoadedEventEnd","loadEventStart","visuallyComplete","interactiveWindowStartTime","interactiveWindowTickTime","pageRenderTimingSent","apply","keys","map","k","speedIndex","timeToInteractive"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/lib/modules/timing.js"],"sourcesContent":["import { hasTag } from '../app/guards.js';\nimport { isURL, getTimeOrigin } from '../utils.js';\nimport { ResourceTiming, PageLoadTiming, PageRenderTiming } from '../app/messages.gen.js';\nfunction getPaintBlocks(resources) {\n    const paintBlocks = [];\n    const elements = document.getElementsByTagName('*');\n    const styleURL = /url\\((\"[^\"]*\"|'[^']*'|[^)]*)\\)/i;\n    for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        let src = '';\n        if (hasTag(element, 'img')) {\n            src = element.currentSrc || element.src;\n        }\n        if (!src) {\n            const backgroundImage = getComputedStyle(element).getPropertyValue('background-image');\n            if (backgroundImage) {\n                const matches = styleURL.exec(backgroundImage);\n                if (matches !== null) {\n                    src = matches[1];\n                    if (src.startsWith('\"') || src.startsWith(\"'\")) {\n                        src = src.substr(1, src.length - 2);\n                    }\n                }\n            }\n        }\n        if (!src)\n            continue;\n        const time = src.substr(0, 10) === 'data:image' ? 0 : resources[src];\n        if (time === undefined)\n            continue;\n        const rect = element.getBoundingClientRect();\n        const top = Math.max(rect.top, 0);\n        const left = Math.max(rect.left, 0);\n        const bottom = Math.min(rect.bottom, window.innerHeight ||\n            (document.documentElement && document.documentElement.clientHeight) ||\n            0);\n        const right = Math.min(rect.right, window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || 0);\n        if (bottom <= top || right <= left)\n            continue;\n        const area = (bottom - top) * (right - left);\n        paintBlocks.push({ time, area });\n    }\n    return paintBlocks;\n}\nfunction calculateSpeedIndex(firstContentfulPaint, paintBlocks) {\n    let a = (Math.max((document.documentElement && document.documentElement.clientWidth) || 0, window.innerWidth || 0) *\n        Math.max((document.documentElement && document.documentElement.clientHeight) || 0, window.innerHeight || 0)) /\n        10;\n    let s = a * firstContentfulPaint;\n    for (let i = 0; i < paintBlocks.length; i++) {\n        const { time, area } = paintBlocks[i];\n        a += area;\n        s += area * (time > firstContentfulPaint ? time : firstContentfulPaint);\n    }\n    return a === 0 ? 0 : s / a;\n}\nexport default function (app, opts) {\n    const options = Object.assign({\n        captureResourceTimings: true,\n        capturePageLoadTimings: true,\n        capturePageRenderTimings: true,\n        excludedResourceUrls: [],\n    }, opts);\n    if (!('PerformanceObserver' in window)) {\n        options.captureResourceTimings = false;\n    }\n    if (!options.captureResourceTimings) {\n        return;\n    } // Resources are necessary for all timings\n    let resources = {};\n    function resourceTiming(entry) {\n        var _a;\n        if (entry.duration < 0 || !isURL(entry.name) || app.isServiceURL(entry.name))\n            return;\n        if (resources !== null) {\n            resources[entry.name] = entry.startTime + entry.duration;\n        }\n        let shouldSkip = false;\n        (_a = options.excludedResourceUrls) === null || _a === void 0 ? void 0 : _a.forEach((url) => {\n            if (entry.name.startsWith(url)) {\n                shouldSkip = true;\n                return;\n            }\n        });\n        if (shouldSkip) {\n            return;\n        }\n        app.send(ResourceTiming(entry.startTime + getTimeOrigin(), entry.duration, entry.responseStart && entry.startTime ? entry.responseStart - entry.startTime : 0, entry.transferSize > entry.encodedBodySize ? entry.transferSize - entry.encodedBodySize : 0, entry.encodedBodySize || 0, entry.decodedBodySize || 0, entry.name, entry.initiatorType, entry.transferSize, \n        // @ts-ignore\n        (entry.responseStatus && entry.responseStatus === 304) || entry.transferSize === 0));\n    }\n    const observer = new PerformanceObserver((list) => list.getEntries().forEach(resourceTiming));\n    let prevSessionID;\n    app.attachStartCallback(function ({ sessionID }) {\n        if (sessionID !== prevSessionID) {\n            // Send past page resources on a newly started session\n            performance.getEntriesByType('resource').forEach(resourceTiming);\n            prevSessionID = sessionID;\n        }\n        observer.observe({ entryTypes: ['resource'] });\n    });\n    app.attachStopCallback(function () {\n        observer.disconnect();\n    });\n    let firstPaint = 0, firstContentfulPaint = 0;\n    if (options.capturePageLoadTimings) {\n        let pageLoadTimingSent = false;\n        app.ticker.attach(() => {\n            if (pageLoadTimingSent) {\n                return;\n            }\n            if (firstPaint === 0 || firstContentfulPaint === 0) {\n                performance.getEntriesByType('paint').forEach((entry) => {\n                    const { name, startTime } = entry;\n                    switch (name) {\n                        case 'first-paint':\n                            firstPaint = startTime;\n                            break;\n                        case 'first-contentful-paint':\n                            firstContentfulPaint = startTime;\n                            break;\n                    }\n                });\n            }\n            if (performance.timing.loadEventEnd || performance.now() > 30000) {\n                pageLoadTimingSent = true;\n                const { \n                // should be ok to use here, (https://github.com/mdn/content/issues/4713)\n                // since it is compared with the values obtained on the page load (before any possible sleep state)\n                // deprecated though\n                navigationStart, requestStart, responseStart, responseEnd, domContentLoadedEventStart, domContentLoadedEventEnd, loadEventStart, loadEventEnd, } = performance.timing;\n                app.send(PageLoadTiming(requestStart - navigationStart || 0, responseStart - navigationStart || 0, responseEnd - navigationStart || 0, domContentLoadedEventStart - navigationStart || 0, domContentLoadedEventEnd - navigationStart || 0, loadEventStart - navigationStart || 0, loadEventEnd - navigationStart || 0, firstPaint, firstContentfulPaint));\n            }\n        }, 30);\n    }\n    if (options.capturePageRenderTimings) {\n        let visuallyComplete = 0, interactiveWindowStartTime = 0, interactiveWindowTickTime = 0, paintBlocks = null;\n        let pageRenderTimingSent = false;\n        app.ticker.attach(() => {\n            if (pageRenderTimingSent) {\n                return;\n            }\n            const time = performance.now();\n            if (resources !== null) {\n                visuallyComplete = Math.max.apply(null, Object.keys(resources).map((k) => resources[k]));\n                if (time - visuallyComplete > 1000) {\n                    paintBlocks = getPaintBlocks(resources);\n                    resources = null;\n                }\n            }\n            if (interactiveWindowTickTime !== null) {\n                if (time - interactiveWindowTickTime > 50) {\n                    interactiveWindowStartTime = time;\n                }\n                interactiveWindowTickTime = time - interactiveWindowStartTime > 5000 ? null : time;\n            }\n            if ((paintBlocks !== null && interactiveWindowTickTime === null) || time > 30000) {\n                pageRenderTimingSent = true;\n                resources = null;\n                const speedIndex = paintBlocks === null\n                    ? 0\n                    : calculateSpeedIndex(firstContentfulPaint || firstPaint, paintBlocks);\n                const { domContentLoadedEventEnd, navigationStart } = performance.timing;\n                const timeToInteractive = interactiveWindowTickTime === null\n                    ? Math.max(interactiveWindowStartTime, firstContentfulPaint, domContentLoadedEventEnd - navigationStart || 0)\n                    : 0;\n                app.send(PageRenderTiming(speedIndex, firstContentfulPaint > visuallyComplete ? firstContentfulPaint : visuallyComplete, timeToInteractive));\n            }\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}