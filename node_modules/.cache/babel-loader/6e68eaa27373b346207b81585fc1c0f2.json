{"ast":null,"code":"import { createEventListener, deleteEventListener } from '../utils.js';\nexport default class Nodes {\n  constructor(node_id) {\n    this.node_id = node_id;\n    this.nodes = [];\n    this.totalNodeAmount = 0;\n    this.nodeCallbacks = [];\n    this.elementListeners = new Map();\n    this.scanTree = cb => {\n      this.nodes.forEach(node => cb(node));\n    };\n  }\n  // Attached once per Tracker instance\n  attachNodeCallback(nodeCallback) {\n    this.nodeCallbacks.push(nodeCallback);\n  }\n  attachNodeListener(node, type, listener, useCapture = true) {\n    const id = this.getID(node);\n    if (id === undefined) {\n      return;\n    }\n    createEventListener(node, type, listener, useCapture);\n    let listeners = this.elementListeners.get(id);\n    if (listeners === undefined) {\n      listeners = [];\n      this.elementListeners.set(id, listeners);\n    }\n    listeners.push([type, listener, useCapture]);\n  }\n  registerNode(node) {\n    let id = node[this.node_id];\n    const isNew = id === undefined;\n    if (isNew) {\n      this.totalNodeAmount++;\n      id = this.nodes.length;\n      this.nodes[id] = node;\n      node[this.node_id] = id;\n    }\n    return [id, isNew];\n  }\n  unregisterNode(node) {\n    const id = node[this.node_id];\n    if (id !== undefined) {\n      delete node[this.node_id];\n      delete this.nodes[id];\n      const listeners = this.elementListeners.get(id);\n      if (listeners !== undefined) {\n        this.elementListeners.delete(id);\n        listeners.forEach(listener => deleteEventListener(node, listener[0], listener[1], listener[2]));\n      }\n      this.totalNodeAmount--;\n    }\n    return id;\n  }\n  cleanTree() {\n    // sadly we keep empty items in array here resulting in some memory still being used\n    // but its still better than keeping dead nodes or undef elements\n    // plus we keep our index positions for new/alive nodes\n    // performance test: 3ms for 30k nodes with 17k dead ones\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i];\n      if (node && !document.contains(node)) {\n        this.unregisterNode(node);\n      }\n    }\n  }\n  callNodeCallbacks(node, isStart) {\n    this.nodeCallbacks.forEach(cb => cb(node, isStart));\n  }\n  getID(node) {\n    if (!node) return undefined;\n    return node[this.node_id];\n  }\n  getNode(id) {\n    return this.nodes[id];\n  }\n  getNodeCount() {\n    return this.totalNodeAmount;\n  }\n  clear() {\n    for (let id = 0; id < this.nodes.length; id++) {\n      const node = this.nodes[id];\n      if (!node) {\n        continue;\n      }\n      this.unregisterNode(node);\n    }\n    this.nodes.length = 0;\n  }\n}","map":{"version":3,"names":["createEventListener","deleteEventListener","Nodes","constructor","node_id","nodes","totalNodeAmount","nodeCallbacks","elementListeners","Map","scanTree","cb","forEach","node","attachNodeCallback","nodeCallback","push","attachNodeListener","type","listener","useCapture","id","getID","undefined","listeners","get","set","registerNode","isNew","length","unregisterNode","delete","cleanTree","i","document","contains","callNodeCallbacks","isStart","getNode","getNodeCount","clear"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/lib/app/nodes.js"],"sourcesContent":["import { createEventListener, deleteEventListener } from '../utils.js';\nexport default class Nodes {\n    constructor(node_id) {\n        this.node_id = node_id;\n        this.nodes = [];\n        this.totalNodeAmount = 0;\n        this.nodeCallbacks = [];\n        this.elementListeners = new Map();\n        this.scanTree = (cb) => {\n            this.nodes.forEach((node) => cb(node));\n        };\n    }\n    // Attached once per Tracker instance\n    attachNodeCallback(nodeCallback) {\n        this.nodeCallbacks.push(nodeCallback);\n    }\n    attachNodeListener(node, type, listener, useCapture = true) {\n        const id = this.getID(node);\n        if (id === undefined) {\n            return;\n        }\n        createEventListener(node, type, listener, useCapture);\n        let listeners = this.elementListeners.get(id);\n        if (listeners === undefined) {\n            listeners = [];\n            this.elementListeners.set(id, listeners);\n        }\n        listeners.push([type, listener, useCapture]);\n    }\n    registerNode(node) {\n        let id = node[this.node_id];\n        const isNew = id === undefined;\n        if (isNew) {\n            this.totalNodeAmount++;\n            id = this.nodes.length;\n            this.nodes[id] = node;\n            node[this.node_id] = id;\n        }\n        return [id, isNew];\n    }\n    unregisterNode(node) {\n        const id = node[this.node_id];\n        if (id !== undefined) {\n            delete node[this.node_id];\n            delete this.nodes[id];\n            const listeners = this.elementListeners.get(id);\n            if (listeners !== undefined) {\n                this.elementListeners.delete(id);\n                listeners.forEach((listener) => deleteEventListener(node, listener[0], listener[1], listener[2]));\n            }\n            this.totalNodeAmount--;\n        }\n        return id;\n    }\n    cleanTree() {\n        // sadly we keep empty items in array here resulting in some memory still being used\n        // but its still better than keeping dead nodes or undef elements\n        // plus we keep our index positions for new/alive nodes\n        // performance test: 3ms for 30k nodes with 17k dead ones\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (node && !document.contains(node)) {\n                this.unregisterNode(node);\n            }\n        }\n    }\n    callNodeCallbacks(node, isStart) {\n        this.nodeCallbacks.forEach((cb) => cb(node, isStart));\n    }\n    getID(node) {\n        if (!node)\n            return undefined;\n        return node[this.node_id];\n    }\n    getNode(id) {\n        return this.nodes[id];\n    }\n    getNodeCount() {\n        return this.totalNodeAmount;\n    }\n    clear() {\n        for (let id = 0; id < this.nodes.length; id++) {\n            const node = this.nodes[id];\n            if (!node) {\n                continue;\n            }\n            this.unregisterNode(node);\n        }\n        this.nodes.length = 0;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}