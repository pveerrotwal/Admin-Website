{"ast":null,"code":"/**\n * I took inspiration in few stack exchange posts\n * and Tencent vConsole library (MIT)\n * by wrapping the XMLHttpRequest object in a Proxy\n * we can intercept the network requests\n * in not-so-hacky way\n * */\nimport NetworkMessage, { RequestState } from './networkMessage.js';\nimport { formatByteSize, genStringBody, getStringResponseByType, getURL } from './utils.js';\nexport class ResponseProxyHandler {\n  constructor(resp, item) {\n    this.resp = resp;\n    this.item = item;\n    this.mockReader();\n  }\n  set(target, key, value) {\n    return Reflect.set(target, key, value);\n  }\n  get(target, key) {\n    const value = Reflect.get(target, key);\n    switch (key) {\n      case 'arrayBuffer':\n      case 'blob':\n      case 'formData':\n      case 'json':\n      case 'text':\n        return () => {\n          this.item.responseType = key.toLowerCase();\n          // @ts-ignore\n          return value.apply(target).then(resp => {\n            this.item.response = getStringResponseByType(this.item.responseType, resp);\n            return resp;\n          });\n        };\n    }\n    if (typeof value === 'function') {\n      return value.bind(target);\n    } else {\n      return value;\n    }\n  }\n  mockReader() {\n    let readerReceivedValue;\n    if (!this.resp.body) {\n      // some browsers do not return `body` in some cases, like `OPTIONS` method\n      return;\n    }\n    if (typeof this.resp.body.getReader !== 'function') {\n      return;\n    }\n    const _getReader = this.resp.body.getReader;\n    // @ts-ignore\n    this.resp.body.getReader = () => {\n      const reader = _getReader.apply(this.resp.body);\n      // when readyState is already 4,\n      // it's not a chunked stream, or it had already been read.\n      // so should not update status.\n      if (this.item.readyState === RequestState.DONE) {\n        return reader;\n      }\n      const _read = reader.read;\n      const _cancel = reader.cancel;\n      this.item.responseType = 'arraybuffer';\n      // @ts-ignore\n      reader.read = () => {\n        return _read.apply(reader).then(result => {\n          if (!readerReceivedValue) {\n            // @ts-ignore\n            readerReceivedValue = new Uint8Array(result.value);\n          } else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const newValue = new Uint8Array(readerReceivedValue.length + result.value.length);\n            newValue.set(readerReceivedValue);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            newValue.set(result.value, readerReceivedValue.length);\n            readerReceivedValue = newValue;\n          }\n          this.item.endTime = performance.now();\n          this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n          this.item.readyState = result.done ? 4 : 3;\n          this.item.statusText = result.done ? String(this.item.status) : 'Loading';\n          this.item.responseSize = readerReceivedValue.length;\n          this.item.responseSizeText = formatByteSize(this.item.responseSize);\n          if (result.done) {\n            this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);\n          }\n          return result;\n        });\n      };\n      reader.cancel = (...args) => {\n        this.item.cancelState = 2;\n        this.item.statusText = 'Cancel';\n        this.item.endTime = performance.now();\n        this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n        this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);\n        return _cancel.apply(reader, args);\n      };\n      return reader;\n    };\n  }\n}\nexport class FetchProxyHandler {\n  constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n    this.ignoredHeaders = ignoredHeaders;\n    this.setSessionTokenHeader = setSessionTokenHeader;\n    this.sanitize = sanitize;\n    this.sendMessage = sendMessage;\n    this.isServiceUrl = isServiceUrl;\n    this.tokenUrlMatcher = tokenUrlMatcher;\n  }\n  apply(target, _, argsList) {\n    const input = argsList[0];\n    const init = argsList[1];\n    if (!input ||\n    // @ts-ignore\n    typeof input !== 'string' && !(input === null || input === void 0 ? void 0 : input.url)) {\n      return target.apply(window, argsList);\n    }\n    const isORUrl = input instanceof URL || typeof input === 'string' ? this.isServiceUrl(String(input)) : this.isServiceUrl(String(input.url));\n    if (isORUrl) {\n      return target.apply(window, argsList);\n    }\n    const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);\n    this.beforeFetch(item, input, init);\n    this.setSessionTokenHeader((name, value) => {\n      if (this.tokenUrlMatcher !== undefined) {\n        if (!this.tokenUrlMatcher(item.url)) {\n          return;\n        }\n      }\n      if (argsList[1] === undefined && argsList[0] instanceof Request) {\n        return argsList[0].headers.append(name, value);\n      } else {\n        if (!argsList[1]) argsList[1] = {};\n        if (argsList[1].headers === undefined) {\n          argsList[1] = Object.assign(Object.assign({}, argsList[1]), {\n            headers: {}\n          });\n        }\n        if (argsList[1].headers instanceof Headers) {\n          argsList[1].headers.append(name, value);\n        } else if (Array.isArray(argsList[1].headers)) {\n          argsList[1].headers.push([name, value]);\n        } else {\n          // @ts-ignore\n          argsList[1].headers[name] = value;\n        }\n      }\n    });\n    return target.apply(window, argsList).then(this.afterFetch(item)).catch(e => {\n      // mock finally\n      item.endTime = performance.now();\n      item.duration = item.endTime - (item.startTime || item.endTime);\n      throw e;\n    });\n  }\n  beforeFetch(item, input, init) {\n    let url,\n      method = 'GET',\n      requestHeader = {};\n    // handle `input` content\n    if (typeof input === 'string') {\n      // when `input` is a string\n      method = (init === null || init === void 0 ? void 0 : init.method) || 'GET';\n      url = getURL(input);\n      requestHeader = (init === null || init === void 0 ? void 0 : init.headers) || {};\n    } else {\n      // when `input` is a `Request` object\n      method = input.method || 'GET';\n      url = getURL(input.url);\n      requestHeader = input.headers;\n    }\n    item.method = method;\n    item.requestType = 'fetch';\n    item.requestHeader = requestHeader;\n    item.url = url.toString();\n    item.name = (url.pathname.split('/').pop() || '') + url.search;\n    item.status = 0;\n    item.statusText = 'Pending';\n    item.readyState = 1;\n    if (!item.startTime) {\n      // UNSENT\n      item.startTime = performance.now();\n    }\n    if (Object.prototype.toString.call(requestHeader) === '[object Headers]') {\n      item.requestHeader = {};\n      for (const [key, value] of requestHeader) {\n        item.requestHeader[key] = value;\n      }\n    } else {\n      item.requestHeader = requestHeader;\n    }\n    // save GET data\n    if (url.search && url.searchParams) {\n      item.getData = {};\n      for (const [key, value] of url.searchParams) {\n        item.getData[key] = value;\n      }\n    }\n    // save POST data\n    if (init === null || init === void 0 ? void 0 : init.body) {\n      item.requestData = genStringBody(init.body);\n    }\n  }\n  afterFetch(item) {\n    return resp => {\n      item.endTime = performance.now();\n      item.duration = item.endTime - (item.startTime || item.endTime);\n      item.status = resp.status;\n      item.statusText = String(resp.status);\n      let isChunked = false;\n      item.header = {};\n      for (const [key, value] of resp.headers) {\n        item.header[key] = value;\n        isChunked = value.toLowerCase().indexOf('chunked') > -1 ? true : isChunked;\n      }\n      if (isChunked) {\n        // when `transfer-encoding` is chunked, the response is a stream which is under loading,\n        // so the `readyState` should be 3 (Loading),\n        // and the response should NOT be `clone()` which will affect stream reading.\n        item.readyState = 3;\n      } else {\n        // Otherwise, not chunked, the response is not a stream,\n        // so it's completed and can be cloned for `text()` calling.\n        item.readyState = 4;\n        void this.handleResponseBody(resp.clone(), item).then(responseValue => {\n          item.responseSize = typeof responseValue === 'string' ? responseValue.length : responseValue.byteLength;\n          item.responseSizeText = formatByteSize(item.responseSize);\n          item.response = getStringResponseByType(item.responseType, responseValue);\n          this.sendMessage(item.getMessage());\n        });\n      }\n      return new Proxy(resp, new ResponseProxyHandler(resp, item));\n    };\n  }\n  handleResponseBody(resp, item) {\n    // parse response body by Content-Type\n    const contentType = resp.headers.get('content-type');\n    if (contentType && contentType.includes('application/json')) {\n      item.responseType = 'json';\n      return resp.text();\n    } else if (contentType && (contentType.includes('text/html') || contentType.includes('text/plain'))) {\n      item.responseType = 'text';\n      return resp.text();\n    } else {\n      item.responseType = 'arraybuffer';\n      return resp.arrayBuffer();\n    }\n  }\n}\nexport default class FetchProxy {\n  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n    return new Proxy(fetch, new FetchProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));\n  }\n}","map":{"version":3,"names":["NetworkMessage","RequestState","formatByteSize","genStringBody","getStringResponseByType","getURL","ResponseProxyHandler","constructor","resp","item","mockReader","set","target","key","value","Reflect","get","responseType","toLowerCase","apply","then","response","bind","readerReceivedValue","body","getReader","_getReader","reader","readyState","DONE","_read","read","_cancel","cancel","result","Uint8Array","newValue","length","endTime","performance","now","duration","startTime","done","statusText","String","status","responseSize","responseSizeText","args","cancelState","FetchProxyHandler","ignoredHeaders","setSessionTokenHeader","sanitize","sendMessage","isServiceUrl","tokenUrlMatcher","_","argsList","input","init","url","window","isORUrl","URL","beforeFetch","name","undefined","Request","headers","append","Object","assign","Headers","Array","isArray","push","afterFetch","catch","e","method","requestHeader","requestType","toString","pathname","split","pop","search","prototype","call","searchParams","getData","requestData","isChunked","header","indexOf","handleResponseBody","clone","responseValue","byteLength","getMessage","Proxy","contentType","includes","text","arrayBuffer","FetchProxy","create","fetch"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/lib/modules/Network/fetchProxy.js"],"sourcesContent":["/**\n * I took inspiration in few stack exchange posts\n * and Tencent vConsole library (MIT)\n * by wrapping the XMLHttpRequest object in a Proxy\n * we can intercept the network requests\n * in not-so-hacky way\n * */\nimport NetworkMessage, { RequestState } from './networkMessage.js';\nimport { formatByteSize, genStringBody, getStringResponseByType, getURL } from './utils.js';\nexport class ResponseProxyHandler {\n    constructor(resp, item) {\n        this.resp = resp;\n        this.item = item;\n        this.mockReader();\n    }\n    set(target, key, value) {\n        return Reflect.set(target, key, value);\n    }\n    get(target, key) {\n        const value = Reflect.get(target, key);\n        switch (key) {\n            case 'arrayBuffer':\n            case 'blob':\n            case 'formData':\n            case 'json':\n            case 'text':\n                return () => {\n                    this.item.responseType = key.toLowerCase();\n                    // @ts-ignore\n                    return value.apply(target).then((resp) => {\n                        this.item.response = getStringResponseByType(this.item.responseType, resp);\n                        return resp;\n                    });\n                };\n        }\n        if (typeof value === 'function') {\n            return value.bind(target);\n        }\n        else {\n            return value;\n        }\n    }\n    mockReader() {\n        let readerReceivedValue;\n        if (!this.resp.body) {\n            // some browsers do not return `body` in some cases, like `OPTIONS` method\n            return;\n        }\n        if (typeof this.resp.body.getReader !== 'function') {\n            return;\n        }\n        const _getReader = this.resp.body.getReader;\n        // @ts-ignore\n        this.resp.body.getReader = () => {\n            const reader = _getReader.apply(this.resp.body);\n            // when readyState is already 4,\n            // it's not a chunked stream, or it had already been read.\n            // so should not update status.\n            if (this.item.readyState === RequestState.DONE) {\n                return reader;\n            }\n            const _read = reader.read;\n            const _cancel = reader.cancel;\n            this.item.responseType = 'arraybuffer';\n            // @ts-ignore\n            reader.read = () => {\n                return _read.apply(reader).then((result) => {\n                    if (!readerReceivedValue) {\n                        // @ts-ignore\n                        readerReceivedValue = new Uint8Array(result.value);\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        const newValue = new Uint8Array(readerReceivedValue.length + result.value.length);\n                        newValue.set(readerReceivedValue);\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        newValue.set(result.value, readerReceivedValue.length);\n                        readerReceivedValue = newValue;\n                    }\n                    this.item.endTime = performance.now();\n                    this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n                    this.item.readyState = result.done ? 4 : 3;\n                    this.item.statusText = result.done ? String(this.item.status) : 'Loading';\n                    this.item.responseSize = readerReceivedValue.length;\n                    this.item.responseSizeText = formatByteSize(this.item.responseSize);\n                    if (result.done) {\n                        this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);\n                    }\n                    return result;\n                });\n            };\n            reader.cancel = (...args) => {\n                this.item.cancelState = 2;\n                this.item.statusText = 'Cancel';\n                this.item.endTime = performance.now();\n                this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);\n                this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);\n                return _cancel.apply(reader, args);\n            };\n            return reader;\n        };\n    }\n}\nexport class FetchProxyHandler {\n    constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n        this.ignoredHeaders = ignoredHeaders;\n        this.setSessionTokenHeader = setSessionTokenHeader;\n        this.sanitize = sanitize;\n        this.sendMessage = sendMessage;\n        this.isServiceUrl = isServiceUrl;\n        this.tokenUrlMatcher = tokenUrlMatcher;\n    }\n    apply(target, _, argsList) {\n        const input = argsList[0];\n        const init = argsList[1];\n        if (!input ||\n            // @ts-ignore\n            (typeof input !== 'string' && !(input === null || input === void 0 ? void 0 : input.url))) {\n            return target.apply(window, argsList);\n        }\n        const isORUrl = input instanceof URL || typeof input === 'string'\n            ? this.isServiceUrl(String(input))\n            : this.isServiceUrl(String(input.url));\n        if (isORUrl) {\n            return target.apply(window, argsList);\n        }\n        const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);\n        this.beforeFetch(item, input, init);\n        this.setSessionTokenHeader((name, value) => {\n            if (this.tokenUrlMatcher !== undefined) {\n                if (!this.tokenUrlMatcher(item.url)) {\n                    return;\n                }\n            }\n            if (argsList[1] === undefined && argsList[0] instanceof Request) {\n                return argsList[0].headers.append(name, value);\n            }\n            else {\n                if (!argsList[1])\n                    argsList[1] = {};\n                if (argsList[1].headers === undefined) {\n                    argsList[1] = Object.assign(Object.assign({}, argsList[1]), { headers: {} });\n                }\n                if (argsList[1].headers instanceof Headers) {\n                    argsList[1].headers.append(name, value);\n                }\n                else if (Array.isArray(argsList[1].headers)) {\n                    argsList[1].headers.push([name, value]);\n                }\n                else {\n                    // @ts-ignore\n                    argsList[1].headers[name] = value;\n                }\n            }\n        });\n        return target.apply(window, argsList)\n            .then(this.afterFetch(item))\n            .catch((e) => {\n            // mock finally\n            item.endTime = performance.now();\n            item.duration = item.endTime - (item.startTime || item.endTime);\n            throw e;\n        });\n    }\n    beforeFetch(item, input, init) {\n        let url, method = 'GET', requestHeader = {};\n        // handle `input` content\n        if (typeof input === 'string') {\n            // when `input` is a string\n            method = (init === null || init === void 0 ? void 0 : init.method) || 'GET';\n            url = getURL(input);\n            requestHeader = (init === null || init === void 0 ? void 0 : init.headers) || {};\n        }\n        else {\n            // when `input` is a `Request` object\n            method = input.method || 'GET';\n            url = getURL(input.url);\n            requestHeader = input.headers;\n        }\n        item.method = method;\n        item.requestType = 'fetch';\n        item.requestHeader = requestHeader;\n        item.url = url.toString();\n        item.name = (url.pathname.split('/').pop() || '') + url.search;\n        item.status = 0;\n        item.statusText = 'Pending';\n        item.readyState = 1;\n        if (!item.startTime) {\n            // UNSENT\n            item.startTime = performance.now();\n        }\n        if (Object.prototype.toString.call(requestHeader) === '[object Headers]') {\n            item.requestHeader = {};\n            for (const [key, value] of requestHeader) {\n                item.requestHeader[key] = value;\n            }\n        }\n        else {\n            item.requestHeader = requestHeader;\n        }\n        // save GET data\n        if (url.search && url.searchParams) {\n            item.getData = {};\n            for (const [key, value] of url.searchParams) {\n                item.getData[key] = value;\n            }\n        }\n        // save POST data\n        if (init === null || init === void 0 ? void 0 : init.body) {\n            item.requestData = genStringBody(init.body);\n        }\n    }\n    afterFetch(item) {\n        return (resp) => {\n            item.endTime = performance.now();\n            item.duration = item.endTime - (item.startTime || item.endTime);\n            item.status = resp.status;\n            item.statusText = String(resp.status);\n            let isChunked = false;\n            item.header = {};\n            for (const [key, value] of resp.headers) {\n                item.header[key] = value;\n                isChunked = value.toLowerCase().indexOf('chunked') > -1 ? true : isChunked;\n            }\n            if (isChunked) {\n                // when `transfer-encoding` is chunked, the response is a stream which is under loading,\n                // so the `readyState` should be 3 (Loading),\n                // and the response should NOT be `clone()` which will affect stream reading.\n                item.readyState = 3;\n            }\n            else {\n                // Otherwise, not chunked, the response is not a stream,\n                // so it's completed and can be cloned for `text()` calling.\n                item.readyState = 4;\n                void this.handleResponseBody(resp.clone(), item).then((responseValue) => {\n                    item.responseSize =\n                        typeof responseValue === 'string' ? responseValue.length : responseValue.byteLength;\n                    item.responseSizeText = formatByteSize(item.responseSize);\n                    item.response = getStringResponseByType(item.responseType, responseValue);\n                    this.sendMessage(item.getMessage());\n                });\n            }\n            return new Proxy(resp, new ResponseProxyHandler(resp, item));\n        };\n    }\n    handleResponseBody(resp, item) {\n        // parse response body by Content-Type\n        const contentType = resp.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            item.responseType = 'json';\n            return resp.text();\n        }\n        else if (contentType &&\n            (contentType.includes('text/html') || contentType.includes('text/plain'))) {\n            item.responseType = 'text';\n            return resp.text();\n        }\n        else {\n            item.responseType = 'arraybuffer';\n            return resp.arrayBuffer();\n        }\n    }\n}\nexport default class FetchProxy {\n    static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {\n        return new Proxy(fetch, new FetchProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}