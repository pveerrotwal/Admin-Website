{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_INGEST_POINT = void 0;\nconst conditionsManager_js_1 = __importDefault(require(\"../modules/conditionsManager.js\"));\nconst featureFlags_js_1 = __importDefault(require(\"../modules/featureFlags.js\"));\nconst messages_gen_js_1 = require(\"./messages.gen.js\");\nconst messages_gen_js_2 = require(\"./messages.gen.js\");\nconst utils_js_1 = require(\"../utils.js\");\nconst nodes_js_1 = __importDefault(require(\"./nodes.js\"));\nconst top_observer_js_1 = __importDefault(require(\"./observer/top_observer.js\"));\nconst sanitizer_js_1 = __importDefault(require(\"./sanitizer.js\"));\nconst ticker_js_1 = __importDefault(require(\"./ticker.js\"));\nconst logger_js_1 = __importStar(require(\"./logger.js\"));\nconst session_js_1 = __importDefault(require(\"./session.js\"));\nconst fflate_1 = require(\"fflate\");\nconst performance_js_1 = require(\"../modules/performance.js\");\nconst attributeSender_js_1 = __importDefault(require(\"../modules/attributeSender.js\"));\nconst canvas_js_1 = __importDefault(require(\"./canvas.js\"));\nconst index_js_1 = __importDefault(require(\"../modules/userTesting/index.js\"));\nconst tagWatcher_js_1 = __importDefault(require(\"../modules/tagWatcher.js\"));\nconst CANCELED = 'canceled';\nconst uxtStorageKey = 'or_uxt_active';\nconst bufferStorageKey = 'or_buffer_1';\nconst START_ERROR = ':(';\nconst UnsuccessfulStart = reason => ({\n  reason,\n  success: false\n});\nconst SuccessfulStart = body => Object.assign(Object.assign({}, body), {\n  success: true\n});\nvar ActivityState;\n(function (ActivityState) {\n  ActivityState[ActivityState[\"NotActive\"] = 0] = \"NotActive\";\n  ActivityState[ActivityState[\"Starting\"] = 1] = \"Starting\";\n  ActivityState[ActivityState[\"Active\"] = 2] = \"Active\";\n  ActivityState[ActivityState[\"ColdStart\"] = 3] = \"ColdStart\";\n})(ActivityState || (ActivityState = {}));\n// TODO: use backendHost only\nexports.DEFAULT_INGEST_POINT = 'https://api.openreplay.com/ingest';\nfunction getTimezone() {\n  const offset = new Date().getTimezoneOffset() * -1;\n  const sign = offset >= 0 ? '+' : '-';\n  const hours = Math.floor(Math.abs(offset) / 60);\n  const minutes = Math.abs(offset) % 60;\n  return `UTC${sign}${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;\n}\nclass App {\n  constructor(projectKey, sessionToken, options, signalError) {\n    var _a, _b;\n    this.signalError = signalError;\n    this.messages = [];\n    /**\n     * we need 2 buffers, so we don't lose anything\n     * @read coldStart implementation\n     * */\n    this.bufferedMessages1 = [];\n    this.bufferedMessages2 = [];\n    this.startCallbacks = [];\n    this.stopCallbacks = [];\n    this.commitCallbacks = [];\n    this.activityState = ActivityState.NotActive;\n    this.version = '12.0.3'; // TODO: version compatability check inside each plugin.\n    this.compressionThreshold = 24 * 1000;\n    this.restartAttempts = 0;\n    this.bc = null;\n    this.canvasRecorder = null;\n    this.conditionsManager = null;\n    this._usingOldFetchPlugin = false;\n    this.coldStartCommitN = 0;\n    this.delay = 0;\n    this.coldInterval = null;\n    this.orderNumber = 0;\n    this.coldStartTs = 0;\n    this.singleBuffer = false;\n    this.onSessionSent = () => {\n      return;\n    };\n    this.restartCanvasTracking = () => {\n      var _a;\n      (_a = this.canvasRecorder) === null || _a === void 0 ? void 0 : _a.restartTracking();\n    };\n    this.flushBuffer = async buffer => {\n      return new Promise(res => {\n        let ended = false;\n        const messagesBatch = [buffer.shift()];\n        while (!ended) {\n          const nextMsg = buffer[0];\n          if (!nextMsg || nextMsg[0] === 0 /* MType.Timestamp */) {\n            ended = true;\n          } else {\n            messagesBatch.push(buffer.shift());\n          }\n        }\n        this.postToWorker(messagesBatch);\n        res(null);\n      });\n    };\n    this.onUxtCb = [];\n    this.contextId = Math.random().toString(36).slice(2);\n    this.projectKey = projectKey;\n    this.networkOptions = options.network;\n    this.options = Object.assign({\n      revID: '',\n      node_id: '__openreplay_id',\n      session_token_key: '__openreplay_token',\n      session_pageno_key: '__openreplay_pageno',\n      session_reset_key: '__openreplay_reset',\n      session_tabid_key: '__openreplay_tabid',\n      local_uuid_key: '__openreplay_uuid',\n      ingestPoint: exports.DEFAULT_INGEST_POINT,\n      resourceBaseHref: null,\n      __is_snippet: false,\n      __debug_report_edp: null,\n      __debug__: logger_js_1.LogLevel.Silent,\n      __save_canvas_locally: false,\n      localStorage: null,\n      sessionStorage: null,\n      disableStringDict: false,\n      forceSingleTab: false,\n      assistSocketHost: '',\n      fixedCanvasScaling: false\n    }, options);\n    if (!this.options.forceSingleTab && globalThis && 'BroadcastChannel' in globalThis) {\n      const host = location.hostname.split('.').slice(-2).join('_');\n      this.bc = (0, utils_js_1.inIframe)() ? null : new BroadcastChannel(`rick_${host}`);\n    }\n    this.revID = this.options.revID;\n    this.localStorage = (_a = this.options.localStorage) !== null && _a !== void 0 ? _a : window.localStorage;\n    this.sessionStorage = (_b = this.options.sessionStorage) !== null && _b !== void 0 ? _b : window.sessionStorage;\n    this.sanitizer = new sanitizer_js_1.default(this, options);\n    this.nodes = new nodes_js_1.default(this.options.node_id);\n    this.observer = new top_observer_js_1.default(this, options);\n    this.ticker = new ticker_js_1.default(this);\n    this.ticker.attach(() => this.commit());\n    this.debug = new logger_js_1.default(this.options.__debug__);\n    this.session = new session_js_1.default(this, this.options);\n    this.attributeSender = new attributeSender_js_1.default(this, Boolean(this.options.disableStringDict));\n    this.featureFlags = new featureFlags_js_1.default(this);\n    this.tagWatcher = new tagWatcher_js_1.default(this.sessionStorage, this.debug.error, tag => {\n      this.send((0, messages_gen_js_1.TagTrigger)(tag));\n    });\n    this.session.attachUpdateCallback(({\n      userID,\n      metadata\n    }) => {\n      if (userID != null) {\n        // TODO: nullable userID\n        this.send((0, messages_gen_js_2.UserID)(userID));\n      }\n      if (metadata != null) {\n        Object.entries(metadata).forEach(([key, value]) => this.send((0, messages_gen_js_2.Metadata)(key, value)));\n      }\n    });\n    // @deprecated (use sessionHash on start instead)\n    if (sessionToken != null) {\n      this.session.applySessionHash(sessionToken);\n    }\n    try {\n      this.worker = new Worker(URL.createObjectURL(new Blob(['\"use strict\";class t{constructor(t,s,i,e=10,n=1e3,h){this.onUnauthorised=s,this.onFailure=i,this.MAX_ATTEMPTS_COUNT=e,this.ATTEMPT_TIMEOUT=n,this.onCompress=h,this.attemptsCount=0,this.busy=!1,this.queue=[],this.token=null,this.ingestURL=t+\"/v1/web/i\",this.isCompressing=void 0!==h}getQueueStatus(){return 0===this.queue.length&&!this.busy}authorise(t){this.token=t,this.busy||this.sendNext()}push(t){this.busy||!this.token?this.queue.push(t):(this.busy=!0,this.isCompressing&&this.onCompress?this.onCompress(t):this.sendBatch(t))}sendNext(){const t=this.queue.shift();t?(this.busy=!0,this.isCompressing&&this.onCompress?this.onCompress(t):this.sendBatch(t)):this.busy=!1}retry(t,s){this.attemptsCount>=this.MAX_ATTEMPTS_COUNT?this.onFailure(`Failed to send batch after ${this.attemptsCount} attempts.`):(this.attemptsCount++,setTimeout((()=>this.sendBatch(t,s)),this.ATTEMPT_TIMEOUT*this.attemptsCount))}sendBatch(t,s){this.busy=!0;const i={Authorization:`Bearer ${this.token}`};s&&(i[\"Content-Encoding\"]=\"gzip\"),null!==this.token?fetch(this.ingestURL,{body:t,method:\"POST\",headers:i,keepalive:t.length<65536}).then((i=>{if(401===i.status)return this.busy=!1,void this.onUnauthorised();i.status>=400?this.retry(t,s):(this.attemptsCount=0,this.sendNext())})).catch((i=>{console.warn(\"OpenReplay:\",i),this.retry(t,s)})):setTimeout((()=>{this.sendBatch(t,s)}),500)}sendCompressed(t){this.sendBatch(t,!0)}sendUncompressed(t){this.sendBatch(t,!1)}clean(){this.sendNext(),setTimeout((()=>{this.token=null,this.queue.length=0}),10)}}const s=\"function\"==typeof TextEncoder?new TextEncoder:{encode(t){const s=t.length,i=new Uint8Array(3*s);let e=-1;for(let n=0,h=0,r=0;r!==s;){if(n=t.charCodeAt(r),r+=1,n>=55296&&n<=56319){if(r===s){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;break}if(h=t.charCodeAt(r),!(h>=56320&&h<=57343)){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;continue}if(n=1024*(n-55296)+h-56320+65536,r+=1,n>65535){i[e+=1]=240|n>>>18,i[e+=1]=128|n>>>12&63,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n;continue}}n<=127?i[e+=1]=0|n:n<=2047?(i[e+=1]=192|n>>>6,i[e+=1]=128|63&n):(i[e+=1]=224|n>>>12,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n)}return i.subarray(0,e+1)}};class i{constructor(t){this.size=t,this.offset=0,this.checkpointOffset=0,this.data=new Uint8Array(t)}getCurrentOffset(){return this.offset}checkpoint(){this.checkpointOffset=this.offset}get isEmpty(){return 0===this.offset}skip(t){return this.offset+=t,this.offset<=this.size}set(t,s){this.data.set(t,s)}boolean(t){return this.data[this.offset++]=+t,this.offset<=this.size}uint(t){for((t<0||t>Number.MAX_SAFE_INTEGER)&&(t=0);t>=128;)this.data[this.offset++]=t%256|128,t=Math.floor(t/128);return this.data[this.offset++]=t,this.offset<=this.size}int(t){return t=Math.round(t),this.uint(t>=0?2*t:-2*t-1)}string(t){const i=s.encode(t),e=i.byteLength;return!(!this.uint(e)||this.offset+e>this.size)&&(this.data.set(i,this.offset),this.offset+=e,!0)}reset(){this.offset=0,this.checkpointOffset=0}flush(){const t=this.data.slice(0,this.checkpointOffset);return this.reset(),t}}class e extends i{encode(t){switch(t[0]){case 0:case 11:case 114:case 115:return this.uint(t[1]);case 4:case 44:case 47:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3]);case 5:case 20:case 38:case 70:case 75:case 76:case 77:case 82:return this.uint(t[1])&&this.uint(t[2]);case 6:return this.int(t[1])&&this.int(t[2]);case 7:return!0;case 8:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.string(t[4])&&this.boolean(t[5]);case 9:case 10:case 24:case 51:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3]);case 12:case 61:case 71:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3]);case 13:case 14:case 17:case 50:case 54:return this.uint(t[1])&&this.string(t[2]);case 16:return this.uint(t[1])&&this.int(t[2])&&this.int(t[3]);case 18:return this.uint(t[1])&&this.string(t[2])&&this.int(t[3]);case 19:return this.uint(t[1])&&this.boolean(t[2]);case 21:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8]);case 22:case 27:case 30:case 41:case 45:case 46:case 63:case 64:case 79:return this.string(t[1])&&this.string(t[2]);case 23:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 28:case 29:case 42:case 117:case 118:return this.string(t[1]);case 37:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3]);case 39:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7]);case 40:return this.string(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 48:case 78:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 49:return this.int(t[1])&&this.int(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 53:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8]);case 55:return this.boolean(t[1]);case 57:case 60:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 58:case 120:return this.int(t[1]);case 59:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6])&&this.string(t[7]);case 67:case 73:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 69:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 81:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.int(t[4])&&this.string(t[5]);case 83:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 84:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6]);case 112:return this.uint(t[1])&&this.string(t[2])&&this.boolean(t[3])&&this.string(t[4])&&this.int(t[5])&&this.int(t[6]);case 113:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3]);case 116:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8])&&this.uint(t[9])&&this.boolean(t[10]);case 119:return this.string(t[1])&&this.uint(t[2])}}}class n{constructor(t,s,i,n,h,r){this.pageNo=t,this.timestamp=s,this.url=i,this.onBatch=n,this.tabId=h,this.onOfflineEnd=r,this.nextIndex=0,this.beaconSize=2e5,this.encoder=new e(this.beaconSize),this.sizeBuffer=new Uint8Array(3),this.isEmpty=!0,this.beaconSizeLimit=1e6,this.prepare()}writeType(t){return this.encoder.uint(t[0])}writeFields(t){return this.encoder.encode(t)}writeSizeAt(t,s){for(let s=0;s<3;s++)this.sizeBuffer[s]=t>>8*s;this.encoder.set(this.sizeBuffer,s)}prepare(){if(!this.encoder.isEmpty)return;const t=[81,1,this.pageNo,this.nextIndex,this.timestamp,this.url],s=[118,this.tabId];this.writeType(t),this.writeFields(t),this.writeWithSize(s),this.isEmpty=!0}writeWithSize(t){const s=this.encoder;if(!this.writeType(t)||!s.skip(3))return!1;const i=s.getCurrentOffset(),e=this.writeFields(t);if(e){const e=s.getCurrentOffset()-i;if(e>16777215)return console.warn(\"OpenReplay: max message size overflow.\"),!1;this.writeSizeAt(e,i-3),s.checkpoint(),this.isEmpty=this.isEmpty&&0===t[0],this.nextIndex++}return e}setBeaconSizeLimit(t){this.beaconSizeLimit=t}writeMessage(t){if(\"q_end\"===t[0])return this.finaliseBatch(),this.onOfflineEnd();0===t[0]&&(this.timestamp=t[1]),4===t[0]&&(this.url=t[1]),this.writeWithSize(t)||(this.finaliseBatch(),this.writeWithSize(t)||(this.encoder=new e(this.beaconSizeLimit),this.prepare(),this.writeWithSize(t)?this.finaliseBatch():console.warn(\"OpenReplay: beacon size overflow. Skipping large message.\",t,this),this.encoder=new e(this.beaconSize),this.prepare()))}finaliseBatch(){if(this.isEmpty)return;const t=this.encoder.flush();this.onBatch(t),this.prepare()}clean(){this.encoder.reset()}}var h;!function(t){t[t.NotActive=0]=\"NotActive\",t[t.Starting=1]=\"Starting\",t[t.Stopping=2]=\"Stopping\",t[t.Active=3]=\"Active\",t[t.Stopped=4]=\"Stopped\"}(h||(h={}));let r=null,u=null,a=h.NotActive;function o(){u&&u.finaliseBatch()}function c(){a=h.Stopping,null!==g&&(clearInterval(g),g=null),u&&(u.clean(),u=null),r&&(r.clean(),setTimeout((()=>{r=null}),20)),setTimeout((()=>{a=h.NotActive}),100)}function p(){a!==h.Stopped&&(postMessage(\"restart\"),c())}let f,g=null;self.onmessage=({data:s})=>{if(null!=s){if(\"stop\"===s)return o(),c(),a=h.Stopped;if(\"forceFlushBatch\"!==s){if(!Array.isArray(s)){if(\"compressed\"===s.type){if(!r)return console.debug(\"OR WebWorker: sender not initialised. Compressed batch.\"),void p();s.batch&&r.sendCompressed(s.batch)}if(\"uncompressed\"===s.type){if(!r)return console.debug(\"OR WebWorker: sender not initialised. Uncompressed batch.\"),void p();s.batch&&r.sendUncompressed(s.batch)}return\"start\"===s.type?(a=h.Starting,r=new t(s.ingestPoint,(()=>{p()}),(t=>{!function(t){postMessage({type:\"failure\",reason:t}),c()}(t)}),s.connAttemptCount,s.connAttemptGap,(t=>{postMessage({type:\"compress\",batch:t},[t.buffer])})),u=new n(s.pageNo,s.timestamp,s.url,(t=>{r&&r.push(t)}),s.tabId,(()=>postMessage({type:\"queue_empty\"}))),null===g&&(g=setInterval(o,1e4)),a=h.Active):\"auth\"===s.type?r?u?(r.authorise(s.token),void(s.beaconSizeLimit&&u.setBeaconSizeLimit(s.beaconSizeLimit))):(console.debug(\"OR WebWorker: writer not initialised. Received auth.\"),void p()):(console.debug(\"OR WebWorker: sender not initialised. Received auth.\"),void p()):void 0}if(u){const t=u;s.forEach((s=>{55===s[0]&&(s[1]?f=setTimeout((()=>p()),18e5):clearTimeout(f)),t.writeMessage(s)}))}else postMessage(\"not_init\"),p()}else o()}else o()};'], {\n        type: 'text/javascript'\n      })));\n      this.worker.onerror = e => {\n        this._debug('webworker_error', e);\n      };\n      this.worker.onmessage = ({\n        data\n      }) => {\n        var _a;\n        if (data === 'restart') {\n          this.stop(false);\n          void this.start({}, true);\n        } else if (data === 'not_init') {\n          this.debug.warn('OR WebWorker: writer not initialised. Restarting tracker');\n        } else if (data.type === 'failure') {\n          this.stop(false);\n          this.debug.error('worker_failed', data.reason);\n          this._debug('worker_failed', data.reason);\n        } else if (data.type === 'compress') {\n          const batch = data.batch;\n          const batchSize = batch.byteLength;\n          if (batchSize > this.compressionThreshold) {\n            (0, fflate_1.gzip)(data.batch, {\n              mtime: 0\n            }, (err, result) => {\n              var _a;\n              if (err) {\n                this.debug.error('Openreplay compression error:', err);\n                this.stop(false);\n                if (this.restartAttempts < 3) {\n                  this.restartAttempts += 1;\n                  void this.start({}, true);\n                }\n              } else {\n                (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({\n                  type: 'compressed',\n                  batch: result\n                });\n              }\n            });\n          } else {\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({\n              type: 'uncompressed',\n              batch: batch\n            });\n          }\n        } else if (data.type === 'queue_empty') {\n          this.onSessionSent();\n        }\n      };\n      const alertWorker = () => {\n        if (this.worker) {\n          this.worker.postMessage(null);\n        }\n      };\n      // keep better tactics, discard others?\n      this.attachEventListener(window, 'beforeunload', alertWorker, false);\n      this.attachEventListener(document.body, 'mouseleave', alertWorker, false, false);\n      // TODO: stop session after inactivity timeout (make configurable)\n      this.attachEventListener(document, 'visibilitychange', alertWorker, false);\n    } catch (e) {\n      this._debug('worker_start', e);\n    }\n    const thisTab = this.session.getTabId();\n    const proto = {\n      // ask if there are any tabs alive\n      ask: 'never-gonna-give-you-up',\n      // yes, there are someone out there\n      resp: 'never-gonna-let-you-down',\n      // you stole someone's identity\n      reg: 'never-gonna-run-around-and-desert-you'\n    };\n    if (this.bc) {\n      this.bc.postMessage({\n        line: proto.ask,\n        source: thisTab,\n        context: this.contextId\n      });\n    }\n    if (this.bc !== null) {\n      this.bc.onmessage = ev => {\n        if (ev.data.context === this.contextId) {\n          return;\n        }\n        if (ev.data.line === proto.resp) {\n          const sessionToken = ev.data.token;\n          this.session.setSessionToken(sessionToken);\n        }\n        if (ev.data.line === proto.reg) {\n          const sessionToken = ev.data.token;\n          this.session.regenerateTabId();\n          this.session.setSessionToken(sessionToken);\n        }\n        if (ev.data.line === proto.ask) {\n          const token = this.session.getSessionToken();\n          if (token && this.bc) {\n            this.bc.postMessage({\n              line: ev.data.source === thisTab ? proto.reg : proto.resp,\n              token,\n              source: thisTab,\n              context: this.contextId\n            });\n          }\n        }\n      };\n    }\n  }\n  _debug(context, e) {\n    if (this.options.__debug_report_edp !== null) {\n      void fetch(this.options.__debug_report_edp, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          context,\n          // @ts-ignore\n          error: `${e}`\n        })\n      });\n    }\n    this.debug.error('OpenReplay error: ', context, e);\n  }\n  send(message, urgent = false) {\n    var _a;\n    if (this.activityState === ActivityState.NotActive) {\n      return;\n    }\n    // === Back compatibility with Fetch/Axios plugins ===\n    if (message[0] === 39 /* MType.Fetch */) {\n      this._usingOldFetchPlugin = true;\n      (0, utils_js_1.deprecationWarn)('Fetch plugin', \"'network' init option\", '/installation/network-options');\n      (0, utils_js_1.deprecationWarn)('Axios plugin', \"'network' init option\", '/installation/network-options');\n    }\n    if (this._usingOldFetchPlugin && message[0] === 83 /* MType.NetworkRequest */) {\n      return;\n    }\n    // ====================================================\n    if (this.activityState === ActivityState.ColdStart) {\n      this.bufferedMessages1.push(message);\n      if (!this.singleBuffer) {\n        this.bufferedMessages2.push(message);\n      }\n      (_a = this.conditionsManager) === null || _a === void 0 ? void 0 : _a.processMessage(message);\n    } else {\n      this.messages.push(message);\n    }\n    // TODO: commit on start if there were `urgent` sends;\n    // Clarify where urgent can be used for;\n    // Clarify workflow for each type of message in case it was sent before start\n    //      (like Fetch before start; maybe add an option \"preCapture: boolean\" or sth alike)\n    // Careful: `this.delay` is equal to zero before start so all Timestamp-s will have to be updated on start\n    if (this.activityState === ActivityState.Active && urgent) {\n      this.commit();\n    }\n  }\n  /**\n   * Normal workflow: add timestamp and tab data to batch, then commit it\n   * every ~30ms\n   * */\n  _nCommit() {\n    if (this.worker !== undefined && this.messages.length) {\n      (0, utils_js_1.requestIdleCb)(() => {\n        var _a;\n        this.messages.unshift((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n        this.messages.unshift((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n        // why I need to add opt chaining?\n        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(this.messages);\n        this.commitCallbacks.forEach(cb => cb(this.messages));\n        this.messages.length = 0;\n      });\n    }\n  }\n  /**\n   * Cold start: add timestamp and tab data to both batches\n   * every 2nd tick, ~60ms\n   * this will make batches a bit larger and replay will work with bigger jumps every frame\n   * but in turn we don't overload batch writer on session start with 1000 batches\n   * */\n  _cStartCommit() {\n    this.coldStartCommitN += 1;\n    if (this.coldStartCommitN === 2) {\n      this.bufferedMessages1.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n      this.bufferedMessages1.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n      this.bufferedMessages2.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n      this.bufferedMessages2.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n      this.coldStartCommitN = 0;\n    }\n  }\n  commit() {\n    if (this.activityState === ActivityState.ColdStart) {\n      this._cStartCommit();\n    } else {\n      this._nCommit();\n    }\n  }\n  postToWorker(messages) {\n    var _a;\n    (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(messages);\n    this.commitCallbacks.forEach(cb => cb(messages));\n    messages.length = 0;\n  }\n  timestamp() {\n    return (0, utils_js_1.now)() + this.delay;\n  }\n  safe(fn) {\n    const app = this;\n    return function (...args) {\n      try {\n        fn.apply(this, args);\n      } catch (e) {\n        app._debug('safe_fn_call', e);\n        // time: this.timestamp(),\n        // name: e.name,\n        // message: e.message,\n        // stack: e.stack\n      }\n    }; // TODO: correct typing\n  }\n  attachCommitCallback(cb) {\n    this.commitCallbacks.push(cb);\n  }\n  attachStartCallback(cb, useSafe = false) {\n    if (useSafe) {\n      cb = this.safe(cb);\n    }\n    this.startCallbacks.push(cb);\n  }\n  attachStopCallback(cb, useSafe = false) {\n    if (useSafe) {\n      cb = this.safe(cb);\n    }\n    this.stopCallbacks.push(cb);\n  }\n  // Use  app.nodes.attachNodeListener for registered nodes instead\n  attachEventListener(target, type, listener, useSafe = true, useCapture = true) {\n    if (useSafe) {\n      listener = this.safe(listener);\n    }\n    this.attachStartCallback(() => target ? (0, utils_js_1.createEventListener)(target, type, listener, useCapture) : null, useSafe);\n    this.attachStopCallback(() => target ? (0, utils_js_1.deleteEventListener)(target, type, listener, useCapture) : null, useSafe);\n  }\n  // TODO: full correct semantic\n  checkRequiredVersion(version) {\n    const reqVer = version.split(/[.-]/);\n    const ver = this.version.split(/[.-]/);\n    for (let i = 0; i < 3; i++) {\n      if (isNaN(Number(ver[i])) || isNaN(Number(reqVer[i]))) {\n        return false;\n      }\n      if (Number(ver[i]) > Number(reqVer[i])) {\n        return true;\n      }\n      if (Number(ver[i]) < Number(reqVer[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  getTrackerInfo() {\n    return {\n      userUUID: this.localStorage.getItem(this.options.local_uuid_key),\n      projectKey: this.projectKey,\n      revID: this.revID,\n      trackerVersion: this.version,\n      isSnippet: this.options.__is_snippet\n    };\n  }\n  getSessionInfo() {\n    return Object.assign(Object.assign({}, this.session.getInfo()), this.getTrackerInfo());\n  }\n  getSessionToken() {\n    return this.session.getSessionToken();\n  }\n  getSessionID() {\n    return this.session.getInfo().sessionID || undefined;\n  }\n  getSessionURL(options) {\n    const {\n      projectID,\n      sessionID,\n      timestamp\n    } = this.session.getInfo();\n    if (!projectID || !sessionID) {\n      this.debug.error('OpenReplay error: Unable to build session URL');\n      return undefined;\n    }\n    const ingest = this.options.ingestPoint;\n    const isSaas = /api\\.openreplay\\.com/.test(ingest);\n    const projectPath = isSaas ? 'https://app.openreplay.com/ingest' : ingest;\n    const url = projectPath.replace(/ingest$/, `${projectID}/session/${sessionID}`);\n    if (options === null || options === void 0 ? void 0 : options.withCurrentTime) {\n      const jumpTo = (0, utils_js_1.now)() - timestamp;\n      return `${url}?jumpto=${jumpTo}`;\n    }\n    return url;\n  }\n  getHost() {\n    return new URL(this.options.ingestPoint).host;\n  }\n  getProjectKey() {\n    return this.projectKey;\n  }\n  getBaseHref() {\n    var _a, _b;\n    if (typeof this.options.resourceBaseHref === 'string') {\n      return this.options.resourceBaseHref;\n    } else if (typeof this.options.resourceBaseHref === 'object') {\n      //TODO: switch between types\n    }\n    if (document.baseURI) {\n      return document.baseURI;\n    }\n    // IE only\n    return ((_b = (_a = document.head) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('base')[0]) === null || _b === void 0 ? void 0 : _b.getAttribute('href')) || location.origin + location.pathname;\n  }\n  resolveResourceURL(resourceURL) {\n    const base = new URL(this.getBaseHref());\n    base.pathname += '/' + new URL(resourceURL).pathname;\n    base.pathname.replace(/\\/+/g, '/');\n    return base.toString();\n  }\n  isServiceURL(url) {\n    return url.startsWith(this.options.ingestPoint);\n  }\n  active() {\n    return this.activityState === ActivityState.Active;\n  }\n  resetNextPageSession(flag) {\n    if (flag) {\n      this.sessionStorage.setItem(this.options.session_reset_key, 't');\n    } else {\n      this.sessionStorage.removeItem(this.options.session_reset_key);\n    }\n  }\n  checkSessionToken(forceNew) {\n    const lsReset = this.sessionStorage.getItem(this.options.session_reset_key) !== null;\n    const needNewSessionID = forceNew || lsReset;\n    const sessionToken = this.session.getSessionToken();\n    return needNewSessionID || !sessionToken;\n  }\n  /**\n   * start buffering messages without starting the actual session, which gives\n   * user 30 seconds to \"activate\" and record session by calling `start()` on conditional trigger\n   * and we will then send buffered batch, so it won't get lost\n   * */\n  async coldStart(startOpts = {}, conditional) {\n    var _a, _b;\n    this.singleBuffer = false;\n    const second = 1000;\n    if (conditional) {\n      this.conditionsManager = new conditionsManager_js_1.default(this, startOpts);\n    }\n    const isNewSession = this.checkSessionToken(startOpts.forceNew);\n    if (conditional) {\n      const r = await fetch(this.options.ingestPoint + '/v1/web/start', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(Object.assign(Object.assign({}, this.getTrackerInfo()), {\n          timestamp: (0, utils_js_1.now)(),\n          doNotRecord: true,\n          bufferDiff: 0,\n          userID: this.session.getInfo().userID,\n          token: undefined,\n          deviceMemory: performance_js_1.deviceMemory,\n          jsHeapSizeLimit: performance_js_1.jsHeapSizeLimit,\n          timezone: getTimezone()\n        }))\n      });\n      const {\n        // this token is needed to fetch conditions and flags,\n        // but it can't be used to record a session\n        token,\n        userBrowser,\n        userCity,\n        userCountry,\n        userDevice,\n        userOS,\n        userState,\n        projectID\n      } = await r.json();\n      this.session.assign({\n        projectID\n      });\n      this.session.setUserInfo({\n        userBrowser,\n        userCity,\n        userCountry,\n        userDevice,\n        userOS,\n        userState\n      });\n      const onStartInfo = {\n        sessionToken: token,\n        userUUID: '',\n        sessionID: ''\n      };\n      this.startCallbacks.forEach(cb => cb(onStartInfo));\n      await ((_a = this.conditionsManager) === null || _a === void 0 ? void 0 : _a.fetchConditions(projectID, token));\n      await this.featureFlags.reloadFlags(token);\n      await this.tagWatcher.fetchTags(this.options.ingestPoint, token);\n      (_b = this.conditionsManager) === null || _b === void 0 ? void 0 : _b.processFlags(this.featureFlags.flags);\n    }\n    const cycle = () => {\n      this.orderNumber += 1;\n      (0, utils_js_1.adjustTimeOrigin)();\n      this.coldStartTs = (0, utils_js_1.now)();\n      if (this.orderNumber % 2 === 0) {\n        this.bufferedMessages1.length = 0;\n        this.bufferedMessages1.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n        this.bufferedMessages1.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n      } else {\n        this.bufferedMessages2.length = 0;\n        this.bufferedMessages2.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n        this.bufferedMessages2.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n      }\n      this.stop(false);\n      this.activityState = ActivityState.ColdStart;\n      if (startOpts.sessionHash) {\n        this.session.applySessionHash(startOpts.sessionHash);\n      }\n      if (startOpts.forceNew) {\n        this.session.reset();\n      }\n      this.session.assign({\n        userID: startOpts.userID,\n        metadata: startOpts.metadata\n      });\n      if (!isNewSession) {\n        this.debug.log('continuing session on new tab', this.session.getTabId());\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this.send((0, messages_gen_js_2.TabChange)(this.session.getTabId()));\n      }\n      this.observer.observe();\n      this.ticker.start();\n    };\n    this.coldInterval = setInterval(() => {\n      cycle();\n    }, 30 * second);\n    cycle();\n  }\n  /**\n   * Starts offline session recording\n   * @param {Object} startOpts - options for session start, same as .start()\n   * @param {Function} onSessionSent - callback that will be called once session is fully sent\n   * */\n  offlineRecording(startOpts = {}, onSessionSent) {\n    this.onSessionSent = onSessionSent;\n    this.singleBuffer = true;\n    const isNewSession = this.checkSessionToken(startOpts.forceNew);\n    (0, utils_js_1.adjustTimeOrigin)();\n    this.coldStartTs = (0, utils_js_1.now)();\n    const saverBuffer = this.localStorage.getItem(bufferStorageKey);\n    if (saverBuffer) {\n      const data = JSON.parse(saverBuffer);\n      this.bufferedMessages1 = Array.isArray(data) ? data : this.bufferedMessages1;\n      this.localStorage.removeItem(bufferStorageKey);\n    }\n    this.bufferedMessages1.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n    this.bufferedMessages1.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n    this.activityState = ActivityState.ColdStart;\n    if (startOpts.sessionHash) {\n      this.session.applySessionHash(startOpts.sessionHash);\n    }\n    if (startOpts.forceNew) {\n      this.session.reset();\n    }\n    this.session.assign({\n      userID: startOpts.userID,\n      metadata: startOpts.metadata\n    });\n    const onStartInfo = {\n      sessionToken: '',\n      userUUID: '',\n      sessionID: ''\n    };\n    this.startCallbacks.forEach(cb => cb(onStartInfo));\n    if (!isNewSession) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      this.send((0, messages_gen_js_2.TabChange)(this.session.getTabId()));\n    }\n    this.observer.observe();\n    this.ticker.start();\n    return {\n      saveBuffer: this.saveBuffer,\n      getBuffer: this.getBuffer,\n      setBuffer: this.setBuffer\n    };\n  }\n  /**\n   * Saves the captured messages in localStorage (or whatever is used in its place)\n   *\n   * Then when this.offlineRecording is called, it will preload this messages and clear the storage item\n   *\n   * Keeping the size of local storage reasonable is up to the end users of this library\n   * */\n  saveBuffer() {\n    this.localStorage.setItem(bufferStorageKey, JSON.stringify(this.bufferedMessages1));\n  }\n  /**\n   * @returns buffer with stored messages for offline recording\n   * */\n  getBuffer() {\n    return this.bufferedMessages1;\n  }\n  /**\n   * Used to set a buffer with messages array\n   * */\n  setBuffer(buffer) {\n    this.bufferedMessages1 = buffer;\n  }\n  /**\n   * Uploads the stored session buffer to backend\n   * @returns promise that resolves once messages are loaded, it has to be awaited\n   * so the session can be uploaded properly\n   * @resolve - if messages were loaded in service worker successfully\n   * @reject {string} - error message\n   * */\n  async uploadOfflineRecording() {\n    var _a, _b;\n    this.stop(false);\n    const timestamp = (0, utils_js_1.now)();\n    (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({\n      type: 'start',\n      pageNo: this.session.incPageNo(),\n      ingestPoint: this.options.ingestPoint,\n      timestamp: this.coldStartTs,\n      url: document.URL,\n      connAttemptCount: this.options.connAttemptCount,\n      connAttemptGap: this.options.connAttemptGap,\n      tabId: this.session.getTabId()\n    });\n    const r = await fetch(this.options.ingestPoint + '/v1/web/start', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(Object.assign(Object.assign({}, this.getTrackerInfo()), {\n        timestamp: timestamp,\n        doNotRecord: false,\n        bufferDiff: timestamp - this.coldStartTs,\n        userID: this.session.getInfo().userID,\n        token: undefined,\n        deviceMemory: performance_js_1.deviceMemory,\n        jsHeapSizeLimit: performance_js_1.jsHeapSizeLimit,\n        timezone: getTimezone()\n      }))\n    });\n    const {\n      token,\n      userBrowser,\n      userCity,\n      userCountry,\n      userDevice,\n      userOS,\n      userState,\n      beaconSizeLimit,\n      projectID\n    } = await r.json();\n    (_b = this.worker) === null || _b === void 0 ? void 0 : _b.postMessage({\n      type: 'auth',\n      token,\n      beaconSizeLimit\n    });\n    this.session.assign({\n      projectID\n    });\n    this.session.setUserInfo({\n      userBrowser,\n      userCity,\n      userCountry,\n      userDevice,\n      userOS,\n      userState\n    });\n    while (this.bufferedMessages1.length > 0) {\n      await this.flushBuffer(this.bufferedMessages1);\n    }\n    this.postToWorker([['q_end']]);\n    this.clearBuffers();\n  }\n  _start(startOpts = {}, resetByWorker = false, conditionName) {\n    const isColdStart = this.activityState === ActivityState.ColdStart;\n    if (isColdStart && this.coldInterval) {\n      clearInterval(this.coldInterval);\n    }\n    if (!this.worker) {\n      const reason = 'No worker found: perhaps, CSP is not set.';\n      this.signalError(reason, []);\n      return Promise.resolve(UnsuccessfulStart(reason));\n    }\n    if (this.activityState === ActivityState.Active || this.activityState === ActivityState.Starting) {\n      const reason = 'OpenReplay: trying to call `start()` on the instance that has been started already.';\n      return Promise.resolve(UnsuccessfulStart(reason));\n    }\n    this.activityState = ActivityState.Starting;\n    if (!isColdStart) {\n      (0, utils_js_1.adjustTimeOrigin)();\n    }\n    if (startOpts.sessionHash) {\n      this.session.applySessionHash(startOpts.sessionHash);\n    }\n    if (startOpts.forceNew) {\n      // Reset session metadata only if requested directly\n      this.session.reset();\n    }\n    this.session.assign({\n      // MBTODO: maybe it would make sense to `forceNew` if the `userID` was changed\n      userID: startOpts.userID,\n      metadata: startOpts.metadata\n    });\n    const timestamp = (0, utils_js_1.now)();\n    this.worker.postMessage({\n      type: 'start',\n      pageNo: this.session.incPageNo(),\n      ingestPoint: this.options.ingestPoint,\n      timestamp: isColdStart ? this.coldStartTs : timestamp,\n      url: document.URL,\n      connAttemptCount: this.options.connAttemptCount,\n      connAttemptGap: this.options.connAttemptGap,\n      tabId: this.session.getTabId()\n    });\n    const sessionToken = this.session.getSessionToken();\n    const isNewSession = this.checkSessionToken(startOpts.forceNew);\n    this.sessionStorage.removeItem(this.options.session_reset_key);\n    this.debug.log('OpenReplay: starting session; need new session id?', isNewSession, 'session token: ', sessionToken);\n    return window.fetch(this.options.ingestPoint + '/v1/web/start', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(Object.assign(Object.assign({}, this.getTrackerInfo()), {\n        timestamp,\n        doNotRecord: false,\n        bufferDiff: timestamp - this.coldStartTs,\n        userID: this.session.getInfo().userID,\n        token: isNewSession ? undefined : sessionToken,\n        deviceMemory: performance_js_1.deviceMemory,\n        jsHeapSizeLimit: performance_js_1.jsHeapSizeLimit,\n        timezone: getTimezone(),\n        condition: conditionName\n      }))\n    }).then(r => {\n      if (r.status === 200) {\n        return r.json();\n      } else {\n        return r.text().then(text => text === CANCELED ? Promise.reject(CANCELED) : Promise.reject(`Server error: ${r.status}. ${text}`));\n      }\n    }).then(async r => {\n      var _a;\n      if (!this.worker) {\n        const reason = 'no worker found after start request (this might not happen)';\n        this.signalError(reason, []);\n        return Promise.reject(reason);\n      }\n      if (this.activityState === ActivityState.NotActive) {\n        const reason = 'Tracker stopped during authorization';\n        this.signalError(reason, []);\n        return Promise.reject(reason);\n      }\n      const {\n        token,\n        userUUID,\n        projectID,\n        beaconSizeLimit,\n        compressionThreshold,\n        // how big the batch should be before we decide to compress it\n        delay,\n        //  derived from token\n        sessionID,\n        //  derived from token\n        startTimestamp,\n        // real startTS (server time), derived from sessionID\n        userBrowser,\n        userCity,\n        userCountry,\n        userDevice,\n        userOS,\n        userState,\n        canvasEnabled,\n        canvasQuality,\n        canvasFPS\n      } = r;\n      if (typeof token !== 'string' || typeof userUUID !== 'string' || typeof startTimestamp !== 'number' && typeof startTimestamp !== 'undefined' || typeof sessionID !== 'string' || typeof delay !== 'number' || typeof beaconSizeLimit !== 'number' && typeof beaconSizeLimit !== 'undefined') {\n        const reason = `Incorrect server response: ${JSON.stringify(r)}`;\n        this.signalError(reason, []);\n        return Promise.reject(reason);\n      }\n      this.delay = delay;\n      this.session.setSessionToken(token);\n      this.session.setUserInfo({\n        userBrowser,\n        userCity,\n        userCountry,\n        userDevice,\n        userOS,\n        userState\n      });\n      this.session.assign({\n        sessionID,\n        timestamp: startTimestamp || timestamp,\n        projectID\n      });\n      this.worker.postMessage({\n        type: 'auth',\n        token,\n        beaconSizeLimit\n      });\n      if (!isNewSession && token === sessionToken) {\n        this.debug.log('continuing session on new tab', this.session.getTabId());\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this.send((0, messages_gen_js_2.TabChange)(this.session.getTabId()));\n      }\n      // (Re)send Metadata for the case of a new session\n      Object.entries(this.session.getInfo().metadata).forEach(([key, value]) => this.send((0, messages_gen_js_2.Metadata)(key, value)));\n      this.localStorage.setItem(this.options.local_uuid_key, userUUID);\n      this.compressionThreshold = compressionThreshold;\n      const onStartInfo = {\n        sessionToken: token,\n        userUUID,\n        sessionID\n      };\n      // TODO: start as early as possible (before receiving the token)\n      /** after start */\n      this.startCallbacks.forEach(cb => cb(onStartInfo)); // MBTODO: callbacks after DOM \"mounted\" (observed)\n      void this.featureFlags.reloadFlags();\n      await this.tagWatcher.fetchTags(this.options.ingestPoint, token);\n      this.activityState = ActivityState.Active;\n      if (canvasEnabled) {\n        this.canvasRecorder = (_a = this.canvasRecorder) !== null && _a !== void 0 ? _a : new canvas_js_1.default(this, {\n          fps: canvasFPS,\n          quality: canvasQuality,\n          isDebug: this.options.__save_canvas_locally,\n          fixedScaling: this.options.fixedCanvasScaling\n        });\n        this.canvasRecorder.startTracking();\n      }\n      /** --------------- COLD START BUFFER ------------------*/\n      if (isColdStart) {\n        const biggestBuffer = this.bufferedMessages1.length > this.bufferedMessages2.length ? this.bufferedMessages1 : this.bufferedMessages2;\n        while (biggestBuffer.length > 0) {\n          await this.flushBuffer(biggestBuffer);\n        }\n        this.clearBuffers();\n        this.commit();\n        /** --------------- COLD START BUFFER ------------------*/\n      } else {\n        this.observer.observe();\n        this.ticker.start();\n      }\n      // get rid of onStart ?\n      if (typeof this.options.onStart === 'function') {\n        this.options.onStart(onStartInfo);\n      }\n      this.restartAttempts = 0;\n      this.uxtManager = this.uxtManager ? this.uxtManager : new index_js_1.default(this, uxtStorageKey);\n      let uxtId;\n      const savedUxtTag = this.localStorage.getItem(uxtStorageKey);\n      if (savedUxtTag) {\n        uxtId = parseInt(savedUxtTag, 10);\n      }\n      if (location === null || location === void 0 ? void 0 : location.search) {\n        const query = new URLSearchParams(location.search);\n        if (query.has('oruxt')) {\n          const qId = query.get('oruxt');\n          uxtId = qId ? parseInt(qId, 10) : undefined;\n        }\n      }\n      if (uxtId) {\n        if (!this.uxtManager.isActive) {\n          // eslint-disable-next-line\n          this.uxtManager.getTest(uxtId, token, Boolean(savedUxtTag)).then(id => {\n            if (id) {\n              this.onUxtCb.forEach(cb => cb(id));\n            }\n          });\n        } else {\n          // @ts-ignore\n          this.onUxtCb.forEach(cb => cb(uxtId));\n        }\n      }\n      return SuccessfulStart(onStartInfo);\n    }).catch(reason => {\n      this.stop();\n      this.session.reset();\n      if (reason === CANCELED) {\n        this.signalError(CANCELED, []);\n        return UnsuccessfulStart(CANCELED);\n      }\n      this._debug('session_start', reason);\n      this.signalError(START_ERROR, []);\n      return UnsuccessfulStart(START_ERROR);\n    });\n  }\n  addOnUxtCb(cb) {\n    // @ts-ignore\n    this.onUxtCb.push(cb);\n  }\n  getUxtId() {\n    var _a;\n    return (_a = this.uxtManager) === null || _a === void 0 ? void 0 : _a.getTestId();\n  }\n  /**\n   * basically we ask other tabs during constructor\n   * and here we just apply 10ms delay just in case\n   * */\n  start(...args) {\n    if (!document.hidden) {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve(this._start(...args));\n        }, 25);\n      });\n    } else {\n      return new Promise(resolve => {\n        const onVisibilityChange = () => {\n          if (!document.hidden) {\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n            setTimeout(() => {\n              resolve(this._start(...args));\n            }, 25);\n          }\n        };\n        document.addEventListener('visibilitychange', onVisibilityChange);\n      });\n    }\n  }\n  forceFlushBatch() {\n    var _a;\n    (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage('forceFlushBatch');\n  }\n  getTabId() {\n    return this.session.getTabId();\n  }\n  clearBuffers() {\n    this.bufferedMessages1.length = 0;\n    this.bufferedMessages2.length = 0;\n  }\n  /**\n   * Creates a named hook that expects event name, data string and msg direction (up/down),\n   * it will skip any message bigger than 5 mb or event name bigger than 255 symbols\n   * @returns {(msgType: string, data: string, dir: \"up\" | \"down\") => void}\n   * */\n  trackWs(channelName) {\n    const channel = channelName;\n    return (msgType, data, dir = 'down') => {\n      if (typeof msgType !== 'string' || typeof data !== 'string' || data.length > 5 * 1024 * 1024 || msgType.length > 255) {\n        return;\n      }\n      this.send((0, messages_gen_js_2.WSChannel)('websocket', channel, data, this.timestamp(), dir, msgType));\n    };\n  }\n  stop(stopWorker = true) {\n    var _a;\n    if (this.activityState !== ActivityState.NotActive) {\n      try {\n        this.attributeSender.clear();\n        this.sanitizer.clear();\n        this.observer.disconnect();\n        this.nodes.clear();\n        this.ticker.stop();\n        this.stopCallbacks.forEach(cb => cb());\n        this.debug.log('OpenReplay tracking stopped.');\n        this.tagWatcher.clear();\n        if (this.worker && stopWorker) {\n          this.worker.postMessage('stop');\n        }\n        (_a = this.canvasRecorder) === null || _a === void 0 ? void 0 : _a.clear();\n      } finally {\n        this.activityState = ActivityState.NotActive;\n      }\n    }\n  }\n}\nexports.default = App;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","DEFAULT_INGEST_POINT","conditionsManager_js_1","require","featureFlags_js_1","messages_gen_js_1","messages_gen_js_2","utils_js_1","nodes_js_1","top_observer_js_1","sanitizer_js_1","ticker_js_1","logger_js_1","session_js_1","fflate_1","performance_js_1","attributeSender_js_1","canvas_js_1","index_js_1","tagWatcher_js_1","CANCELED","uxtStorageKey","bufferStorageKey","START_ERROR","UnsuccessfulStart","reason","success","SuccessfulStart","body","assign","ActivityState","getTimezone","offset","Date","getTimezoneOffset","sign","hours","Math","floor","abs","minutes","String","padStart","App","constructor","projectKey","sessionToken","options","signalError","_a","_b","messages","bufferedMessages1","bufferedMessages2","startCallbacks","stopCallbacks","commitCallbacks","activityState","NotActive","version","compressionThreshold","restartAttempts","bc","canvasRecorder","conditionsManager","_usingOldFetchPlugin","coldStartCommitN","delay","coldInterval","orderNumber","coldStartTs","singleBuffer","onSessionSent","restartCanvasTracking","restartTracking","flushBuffer","buffer","Promise","res","ended","messagesBatch","shift","nextMsg","push","postToWorker","onUxtCb","contextId","random","toString","slice","networkOptions","network","revID","node_id","session_token_key","session_pageno_key","session_reset_key","session_tabid_key","local_uuid_key","ingestPoint","resourceBaseHref","__is_snippet","__debug_report_edp","__debug__","LogLevel","Silent","__save_canvas_locally","localStorage","sessionStorage","disableStringDict","forceSingleTab","assistSocketHost","fixedCanvasScaling","globalThis","host","location","hostname","split","join","inIframe","BroadcastChannel","window","sanitizer","default","nodes","observer","ticker","attach","commit","debug","session","attributeSender","Boolean","featureFlags","tagWatcher","error","tag","send","TagTrigger","attachUpdateCallback","userID","metadata","UserID","entries","forEach","key","Metadata","applySessionHash","worker","Worker","URL","createObjectURL","Blob","type","onerror","e","_debug","onmessage","data","stop","start","warn","batch","batchSize","byteLength","gzip","mtime","err","postMessage","alertWorker","attachEventListener","document","thisTab","getTabId","proto","ask","resp","reg","line","source","context","ev","token","setSessionToken","regenerateTabId","getSessionToken","fetch","method","headers","JSON","stringify","message","urgent","deprecationWarn","ColdStart","processMessage","Active","_nCommit","length","requestIdleCb","unshift","TabData","Timestamp","timestamp","cb","_cStartCommit","now","safe","fn","app","args","apply","attachCommitCallback","attachStartCallback","useSafe","attachStopCallback","target","listener","useCapture","createEventListener","deleteEventListener","checkRequiredVersion","reqVer","ver","i","isNaN","Number","getTrackerInfo","userUUID","getItem","trackerVersion","isSnippet","getSessionInfo","getInfo","getSessionID","sessionID","getSessionURL","projectID","ingest","isSaas","test","projectPath","url","replace","withCurrentTime","jumpTo","getHost","getProjectKey","getBaseHref","baseURI","head","getElementsByTagName","getAttribute","origin","pathname","resolveResourceURL","resourceURL","base","isServiceURL","startsWith","active","resetNextPageSession","flag","setItem","removeItem","checkSessionToken","forceNew","lsReset","needNewSessionID","coldStart","startOpts","conditional","second","isNewSession","r","doNotRecord","bufferDiff","deviceMemory","jsHeapSizeLimit","timezone","userBrowser","userCity","userCountry","userDevice","userOS","userState","json","setUserInfo","onStartInfo","fetchConditions","reloadFlags","fetchTags","processFlags","flags","cycle","adjustTimeOrigin","sessionHash","reset","log","TabChange","observe","setInterval","offlineRecording","saverBuffer","parse","Array","isArray","saveBuffer","getBuffer","setBuffer","uploadOfflineRecording","pageNo","incPageNo","connAttemptCount","connAttemptGap","tabId","beaconSizeLimit","clearBuffers","_start","resetByWorker","conditionName","isColdStart","clearInterval","resolve","Starting","condition","then","status","text","reject","startTimestamp","canvasEnabled","canvasQuality","canvasFPS","fps","quality","isDebug","fixedScaling","startTracking","biggestBuffer","onStart","uxtManager","uxtId","savedUxtTag","parseInt","search","query","URLSearchParams","has","qId","isActive","getTest","id","catch","addOnUxtCb","getUxtId","getTestId","hidden","setTimeout","onVisibilityChange","removeEventListener","addEventListener","forceFlushBatch","trackWs","channelName","channel","msgType","dir","WSChannel","stopWorker","clear","disconnect"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/cjs/app/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_INGEST_POINT = void 0;\nconst conditionsManager_js_1 = __importDefault(require(\"../modules/conditionsManager.js\"));\nconst featureFlags_js_1 = __importDefault(require(\"../modules/featureFlags.js\"));\nconst messages_gen_js_1 = require(\"./messages.gen.js\");\nconst messages_gen_js_2 = require(\"./messages.gen.js\");\nconst utils_js_1 = require(\"../utils.js\");\nconst nodes_js_1 = __importDefault(require(\"./nodes.js\"));\nconst top_observer_js_1 = __importDefault(require(\"./observer/top_observer.js\"));\nconst sanitizer_js_1 = __importDefault(require(\"./sanitizer.js\"));\nconst ticker_js_1 = __importDefault(require(\"./ticker.js\"));\nconst logger_js_1 = __importStar(require(\"./logger.js\"));\nconst session_js_1 = __importDefault(require(\"./session.js\"));\nconst fflate_1 = require(\"fflate\");\nconst performance_js_1 = require(\"../modules/performance.js\");\nconst attributeSender_js_1 = __importDefault(require(\"../modules/attributeSender.js\"));\nconst canvas_js_1 = __importDefault(require(\"./canvas.js\"));\nconst index_js_1 = __importDefault(require(\"../modules/userTesting/index.js\"));\nconst tagWatcher_js_1 = __importDefault(require(\"../modules/tagWatcher.js\"));\nconst CANCELED = 'canceled';\nconst uxtStorageKey = 'or_uxt_active';\nconst bufferStorageKey = 'or_buffer_1';\nconst START_ERROR = ':(';\nconst UnsuccessfulStart = (reason) => ({ reason, success: false });\nconst SuccessfulStart = (body) => (Object.assign(Object.assign({}, body), { success: true }));\nvar ActivityState;\n(function (ActivityState) {\n    ActivityState[ActivityState[\"NotActive\"] = 0] = \"NotActive\";\n    ActivityState[ActivityState[\"Starting\"] = 1] = \"Starting\";\n    ActivityState[ActivityState[\"Active\"] = 2] = \"Active\";\n    ActivityState[ActivityState[\"ColdStart\"] = 3] = \"ColdStart\";\n})(ActivityState || (ActivityState = {}));\n// TODO: use backendHost only\nexports.DEFAULT_INGEST_POINT = 'https://api.openreplay.com/ingest';\nfunction getTimezone() {\n    const offset = new Date().getTimezoneOffset() * -1;\n    const sign = offset >= 0 ? '+' : '-';\n    const hours = Math.floor(Math.abs(offset) / 60);\n    const minutes = Math.abs(offset) % 60;\n    return `UTC${sign}${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;\n}\nclass App {\n    constructor(projectKey, sessionToken, options, signalError) {\n        var _a, _b;\n        this.signalError = signalError;\n        this.messages = [];\n        /**\n         * we need 2 buffers, so we don't lose anything\n         * @read coldStart implementation\n         * */\n        this.bufferedMessages1 = [];\n        this.bufferedMessages2 = [];\n        this.startCallbacks = [];\n        this.stopCallbacks = [];\n        this.commitCallbacks = [];\n        this.activityState = ActivityState.NotActive;\n        this.version = '12.0.3'; // TODO: version compatability check inside each plugin.\n        this.compressionThreshold = 24 * 1000;\n        this.restartAttempts = 0;\n        this.bc = null;\n        this.canvasRecorder = null;\n        this.conditionsManager = null;\n        this._usingOldFetchPlugin = false;\n        this.coldStartCommitN = 0;\n        this.delay = 0;\n        this.coldInterval = null;\n        this.orderNumber = 0;\n        this.coldStartTs = 0;\n        this.singleBuffer = false;\n        this.onSessionSent = () => {\n            return;\n        };\n        this.restartCanvasTracking = () => {\n            var _a;\n            (_a = this.canvasRecorder) === null || _a === void 0 ? void 0 : _a.restartTracking();\n        };\n        this.flushBuffer = async (buffer) => {\n            return new Promise((res) => {\n                let ended = false;\n                const messagesBatch = [buffer.shift()];\n                while (!ended) {\n                    const nextMsg = buffer[0];\n                    if (!nextMsg || nextMsg[0] === 0 /* MType.Timestamp */) {\n                        ended = true;\n                    }\n                    else {\n                        messagesBatch.push(buffer.shift());\n                    }\n                }\n                this.postToWorker(messagesBatch);\n                res(null);\n            });\n        };\n        this.onUxtCb = [];\n        this.contextId = Math.random().toString(36).slice(2);\n        this.projectKey = projectKey;\n        this.networkOptions = options.network;\n        this.options = Object.assign({\n            revID: '',\n            node_id: '__openreplay_id',\n            session_token_key: '__openreplay_token',\n            session_pageno_key: '__openreplay_pageno',\n            session_reset_key: '__openreplay_reset',\n            session_tabid_key: '__openreplay_tabid',\n            local_uuid_key: '__openreplay_uuid',\n            ingestPoint: exports.DEFAULT_INGEST_POINT,\n            resourceBaseHref: null,\n            __is_snippet: false,\n            __debug_report_edp: null,\n            __debug__: logger_js_1.LogLevel.Silent,\n            __save_canvas_locally: false,\n            localStorage: null,\n            sessionStorage: null,\n            disableStringDict: false,\n            forceSingleTab: false,\n            assistSocketHost: '',\n            fixedCanvasScaling: false,\n        }, options);\n        if (!this.options.forceSingleTab && globalThis && 'BroadcastChannel' in globalThis) {\n            const host = location.hostname.split('.').slice(-2).join('_');\n            this.bc = (0, utils_js_1.inIframe)() ? null : new BroadcastChannel(`rick_${host}`);\n        }\n        this.revID = this.options.revID;\n        this.localStorage = (_a = this.options.localStorage) !== null && _a !== void 0 ? _a : window.localStorage;\n        this.sessionStorage = (_b = this.options.sessionStorage) !== null && _b !== void 0 ? _b : window.sessionStorage;\n        this.sanitizer = new sanitizer_js_1.default(this, options);\n        this.nodes = new nodes_js_1.default(this.options.node_id);\n        this.observer = new top_observer_js_1.default(this, options);\n        this.ticker = new ticker_js_1.default(this);\n        this.ticker.attach(() => this.commit());\n        this.debug = new logger_js_1.default(this.options.__debug__);\n        this.session = new session_js_1.default(this, this.options);\n        this.attributeSender = new attributeSender_js_1.default(this, Boolean(this.options.disableStringDict));\n        this.featureFlags = new featureFlags_js_1.default(this);\n        this.tagWatcher = new tagWatcher_js_1.default(this.sessionStorage, this.debug.error, (tag) => {\n            this.send((0, messages_gen_js_1.TagTrigger)(tag));\n        });\n        this.session.attachUpdateCallback(({ userID, metadata }) => {\n            if (userID != null) {\n                // TODO: nullable userID\n                this.send((0, messages_gen_js_2.UserID)(userID));\n            }\n            if (metadata != null) {\n                Object.entries(metadata).forEach(([key, value]) => this.send((0, messages_gen_js_2.Metadata)(key, value)));\n            }\n        });\n        // @deprecated (use sessionHash on start instead)\n        if (sessionToken != null) {\n            this.session.applySessionHash(sessionToken);\n        }\n        try {\n            this.worker = new Worker(URL.createObjectURL(new Blob(['\"use strict\";class t{constructor(t,s,i,e=10,n=1e3,h){this.onUnauthorised=s,this.onFailure=i,this.MAX_ATTEMPTS_COUNT=e,this.ATTEMPT_TIMEOUT=n,this.onCompress=h,this.attemptsCount=0,this.busy=!1,this.queue=[],this.token=null,this.ingestURL=t+\"/v1/web/i\",this.isCompressing=void 0!==h}getQueueStatus(){return 0===this.queue.length&&!this.busy}authorise(t){this.token=t,this.busy||this.sendNext()}push(t){this.busy||!this.token?this.queue.push(t):(this.busy=!0,this.isCompressing&&this.onCompress?this.onCompress(t):this.sendBatch(t))}sendNext(){const t=this.queue.shift();t?(this.busy=!0,this.isCompressing&&this.onCompress?this.onCompress(t):this.sendBatch(t)):this.busy=!1}retry(t,s){this.attemptsCount>=this.MAX_ATTEMPTS_COUNT?this.onFailure(`Failed to send batch after ${this.attemptsCount} attempts.`):(this.attemptsCount++,setTimeout((()=>this.sendBatch(t,s)),this.ATTEMPT_TIMEOUT*this.attemptsCount))}sendBatch(t,s){this.busy=!0;const i={Authorization:`Bearer ${this.token}`};s&&(i[\"Content-Encoding\"]=\"gzip\"),null!==this.token?fetch(this.ingestURL,{body:t,method:\"POST\",headers:i,keepalive:t.length<65536}).then((i=>{if(401===i.status)return this.busy=!1,void this.onUnauthorised();i.status>=400?this.retry(t,s):(this.attemptsCount=0,this.sendNext())})).catch((i=>{console.warn(\"OpenReplay:\",i),this.retry(t,s)})):setTimeout((()=>{this.sendBatch(t,s)}),500)}sendCompressed(t){this.sendBatch(t,!0)}sendUncompressed(t){this.sendBatch(t,!1)}clean(){this.sendNext(),setTimeout((()=>{this.token=null,this.queue.length=0}),10)}}const s=\"function\"==typeof TextEncoder?new TextEncoder:{encode(t){const s=t.length,i=new Uint8Array(3*s);let e=-1;for(let n=0,h=0,r=0;r!==s;){if(n=t.charCodeAt(r),r+=1,n>=55296&&n<=56319){if(r===s){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;break}if(h=t.charCodeAt(r),!(h>=56320&&h<=57343)){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;continue}if(n=1024*(n-55296)+h-56320+65536,r+=1,n>65535){i[e+=1]=240|n>>>18,i[e+=1]=128|n>>>12&63,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n;continue}}n<=127?i[e+=1]=0|n:n<=2047?(i[e+=1]=192|n>>>6,i[e+=1]=128|63&n):(i[e+=1]=224|n>>>12,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n)}return i.subarray(0,e+1)}};class i{constructor(t){this.size=t,this.offset=0,this.checkpointOffset=0,this.data=new Uint8Array(t)}getCurrentOffset(){return this.offset}checkpoint(){this.checkpointOffset=this.offset}get isEmpty(){return 0===this.offset}skip(t){return this.offset+=t,this.offset<=this.size}set(t,s){this.data.set(t,s)}boolean(t){return this.data[this.offset++]=+t,this.offset<=this.size}uint(t){for((t<0||t>Number.MAX_SAFE_INTEGER)&&(t=0);t>=128;)this.data[this.offset++]=t%256|128,t=Math.floor(t/128);return this.data[this.offset++]=t,this.offset<=this.size}int(t){return t=Math.round(t),this.uint(t>=0?2*t:-2*t-1)}string(t){const i=s.encode(t),e=i.byteLength;return!(!this.uint(e)||this.offset+e>this.size)&&(this.data.set(i,this.offset),this.offset+=e,!0)}reset(){this.offset=0,this.checkpointOffset=0}flush(){const t=this.data.slice(0,this.checkpointOffset);return this.reset(),t}}class e extends i{encode(t){switch(t[0]){case 0:case 11:case 114:case 115:return this.uint(t[1]);case 4:case 44:case 47:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3]);case 5:case 20:case 38:case 70:case 75:case 76:case 77:case 82:return this.uint(t[1])&&this.uint(t[2]);case 6:return this.int(t[1])&&this.int(t[2]);case 7:return!0;case 8:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.string(t[4])&&this.boolean(t[5]);case 9:case 10:case 24:case 51:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3]);case 12:case 61:case 71:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3]);case 13:case 14:case 17:case 50:case 54:return this.uint(t[1])&&this.string(t[2]);case 16:return this.uint(t[1])&&this.int(t[2])&&this.int(t[3]);case 18:return this.uint(t[1])&&this.string(t[2])&&this.int(t[3]);case 19:return this.uint(t[1])&&this.boolean(t[2]);case 21:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8]);case 22:case 27:case 30:case 41:case 45:case 46:case 63:case 64:case 79:return this.string(t[1])&&this.string(t[2]);case 23:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 28:case 29:case 42:case 117:case 118:return this.string(t[1]);case 37:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3]);case 39:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7]);case 40:return this.string(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 48:case 78:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 49:return this.int(t[1])&&this.int(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 53:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8]);case 55:return this.boolean(t[1]);case 57:case 60:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 58:case 120:return this.int(t[1]);case 59:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6])&&this.string(t[7]);case 67:case 73:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 69:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 81:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.int(t[4])&&this.string(t[5]);case 83:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 84:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6]);case 112:return this.uint(t[1])&&this.string(t[2])&&this.boolean(t[3])&&this.string(t[4])&&this.int(t[5])&&this.int(t[6]);case 113:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3]);case 116:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8])&&this.uint(t[9])&&this.boolean(t[10]);case 119:return this.string(t[1])&&this.uint(t[2])}}}class n{constructor(t,s,i,n,h,r){this.pageNo=t,this.timestamp=s,this.url=i,this.onBatch=n,this.tabId=h,this.onOfflineEnd=r,this.nextIndex=0,this.beaconSize=2e5,this.encoder=new e(this.beaconSize),this.sizeBuffer=new Uint8Array(3),this.isEmpty=!0,this.beaconSizeLimit=1e6,this.prepare()}writeType(t){return this.encoder.uint(t[0])}writeFields(t){return this.encoder.encode(t)}writeSizeAt(t,s){for(let s=0;s<3;s++)this.sizeBuffer[s]=t>>8*s;this.encoder.set(this.sizeBuffer,s)}prepare(){if(!this.encoder.isEmpty)return;const t=[81,1,this.pageNo,this.nextIndex,this.timestamp,this.url],s=[118,this.tabId];this.writeType(t),this.writeFields(t),this.writeWithSize(s),this.isEmpty=!0}writeWithSize(t){const s=this.encoder;if(!this.writeType(t)||!s.skip(3))return!1;const i=s.getCurrentOffset(),e=this.writeFields(t);if(e){const e=s.getCurrentOffset()-i;if(e>16777215)return console.warn(\"OpenReplay: max message size overflow.\"),!1;this.writeSizeAt(e,i-3),s.checkpoint(),this.isEmpty=this.isEmpty&&0===t[0],this.nextIndex++}return e}setBeaconSizeLimit(t){this.beaconSizeLimit=t}writeMessage(t){if(\"q_end\"===t[0])return this.finaliseBatch(),this.onOfflineEnd();0===t[0]&&(this.timestamp=t[1]),4===t[0]&&(this.url=t[1]),this.writeWithSize(t)||(this.finaliseBatch(),this.writeWithSize(t)||(this.encoder=new e(this.beaconSizeLimit),this.prepare(),this.writeWithSize(t)?this.finaliseBatch():console.warn(\"OpenReplay: beacon size overflow. Skipping large message.\",t,this),this.encoder=new e(this.beaconSize),this.prepare()))}finaliseBatch(){if(this.isEmpty)return;const t=this.encoder.flush();this.onBatch(t),this.prepare()}clean(){this.encoder.reset()}}var h;!function(t){t[t.NotActive=0]=\"NotActive\",t[t.Starting=1]=\"Starting\",t[t.Stopping=2]=\"Stopping\",t[t.Active=3]=\"Active\",t[t.Stopped=4]=\"Stopped\"}(h||(h={}));let r=null,u=null,a=h.NotActive;function o(){u&&u.finaliseBatch()}function c(){a=h.Stopping,null!==g&&(clearInterval(g),g=null),u&&(u.clean(),u=null),r&&(r.clean(),setTimeout((()=>{r=null}),20)),setTimeout((()=>{a=h.NotActive}),100)}function p(){a!==h.Stopped&&(postMessage(\"restart\"),c())}let f,g=null;self.onmessage=({data:s})=>{if(null!=s){if(\"stop\"===s)return o(),c(),a=h.Stopped;if(\"forceFlushBatch\"!==s){if(!Array.isArray(s)){if(\"compressed\"===s.type){if(!r)return console.debug(\"OR WebWorker: sender not initialised. Compressed batch.\"),void p();s.batch&&r.sendCompressed(s.batch)}if(\"uncompressed\"===s.type){if(!r)return console.debug(\"OR WebWorker: sender not initialised. Uncompressed batch.\"),void p();s.batch&&r.sendUncompressed(s.batch)}return\"start\"===s.type?(a=h.Starting,r=new t(s.ingestPoint,(()=>{p()}),(t=>{!function(t){postMessage({type:\"failure\",reason:t}),c()}(t)}),s.connAttemptCount,s.connAttemptGap,(t=>{postMessage({type:\"compress\",batch:t},[t.buffer])})),u=new n(s.pageNo,s.timestamp,s.url,(t=>{r&&r.push(t)}),s.tabId,(()=>postMessage({type:\"queue_empty\"}))),null===g&&(g=setInterval(o,1e4)),a=h.Active):\"auth\"===s.type?r?u?(r.authorise(s.token),void(s.beaconSizeLimit&&u.setBeaconSizeLimit(s.beaconSizeLimit))):(console.debug(\"OR WebWorker: writer not initialised. Received auth.\"),void p()):(console.debug(\"OR WebWorker: sender not initialised. Received auth.\"),void p()):void 0}if(u){const t=u;s.forEach((s=>{55===s[0]&&(s[1]?f=setTimeout((()=>p()),18e5):clearTimeout(f)),t.writeMessage(s)}))}else postMessage(\"not_init\"),p()}else o()}else o()};'], { type: 'text/javascript' })));\n            this.worker.onerror = (e) => {\n                this._debug('webworker_error', e);\n            };\n            this.worker.onmessage = ({ data }) => {\n                var _a;\n                if (data === 'restart') {\n                    this.stop(false);\n                    void this.start({}, true);\n                }\n                else if (data === 'not_init') {\n                    this.debug.warn('OR WebWorker: writer not initialised. Restarting tracker');\n                }\n                else if (data.type === 'failure') {\n                    this.stop(false);\n                    this.debug.error('worker_failed', data.reason);\n                    this._debug('worker_failed', data.reason);\n                }\n                else if (data.type === 'compress') {\n                    const batch = data.batch;\n                    const batchSize = batch.byteLength;\n                    if (batchSize > this.compressionThreshold) {\n                        (0, fflate_1.gzip)(data.batch, { mtime: 0 }, (err, result) => {\n                            var _a;\n                            if (err) {\n                                this.debug.error('Openreplay compression error:', err);\n                                this.stop(false);\n                                if (this.restartAttempts < 3) {\n                                    this.restartAttempts += 1;\n                                    void this.start({}, true);\n                                }\n                            }\n                            else {\n                                (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({ type: 'compressed', batch: result });\n                            }\n                        });\n                    }\n                    else {\n                        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({ type: 'uncompressed', batch: batch });\n                    }\n                }\n                else if (data.type === 'queue_empty') {\n                    this.onSessionSent();\n                }\n            };\n            const alertWorker = () => {\n                if (this.worker) {\n                    this.worker.postMessage(null);\n                }\n            };\n            // keep better tactics, discard others?\n            this.attachEventListener(window, 'beforeunload', alertWorker, false);\n            this.attachEventListener(document.body, 'mouseleave', alertWorker, false, false);\n            // TODO: stop session after inactivity timeout (make configurable)\n            this.attachEventListener(document, 'visibilitychange', alertWorker, false);\n        }\n        catch (e) {\n            this._debug('worker_start', e);\n        }\n        const thisTab = this.session.getTabId();\n        const proto = {\n            // ask if there are any tabs alive\n            ask: 'never-gonna-give-you-up',\n            // yes, there are someone out there\n            resp: 'never-gonna-let-you-down',\n            // you stole someone's identity\n            reg: 'never-gonna-run-around-and-desert-you',\n        };\n        if (this.bc) {\n            this.bc.postMessage({\n                line: proto.ask,\n                source: thisTab,\n                context: this.contextId,\n            });\n        }\n        if (this.bc !== null) {\n            this.bc.onmessage = (ev) => {\n                if (ev.data.context === this.contextId) {\n                    return;\n                }\n                if (ev.data.line === proto.resp) {\n                    const sessionToken = ev.data.token;\n                    this.session.setSessionToken(sessionToken);\n                }\n                if (ev.data.line === proto.reg) {\n                    const sessionToken = ev.data.token;\n                    this.session.regenerateTabId();\n                    this.session.setSessionToken(sessionToken);\n                }\n                if (ev.data.line === proto.ask) {\n                    const token = this.session.getSessionToken();\n                    if (token && this.bc) {\n                        this.bc.postMessage({\n                            line: ev.data.source === thisTab ? proto.reg : proto.resp,\n                            token,\n                            source: thisTab,\n                            context: this.contextId,\n                        });\n                    }\n                }\n            };\n        }\n    }\n    _debug(context, e) {\n        if (this.options.__debug_report_edp !== null) {\n            void fetch(this.options.__debug_report_edp, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    context,\n                    // @ts-ignore\n                    error: `${e}`,\n                }),\n            });\n        }\n        this.debug.error('OpenReplay error: ', context, e);\n    }\n    send(message, urgent = false) {\n        var _a;\n        if (this.activityState === ActivityState.NotActive) {\n            return;\n        }\n        // === Back compatibility with Fetch/Axios plugins ===\n        if (message[0] === 39 /* MType.Fetch */) {\n            this._usingOldFetchPlugin = true;\n            (0, utils_js_1.deprecationWarn)('Fetch plugin', \"'network' init option\", '/installation/network-options');\n            (0, utils_js_1.deprecationWarn)('Axios plugin', \"'network' init option\", '/installation/network-options');\n        }\n        if (this._usingOldFetchPlugin && message[0] === 83 /* MType.NetworkRequest */) {\n            return;\n        }\n        // ====================================================\n        if (this.activityState === ActivityState.ColdStart) {\n            this.bufferedMessages1.push(message);\n            if (!this.singleBuffer) {\n                this.bufferedMessages2.push(message);\n            }\n            (_a = this.conditionsManager) === null || _a === void 0 ? void 0 : _a.processMessage(message);\n        }\n        else {\n            this.messages.push(message);\n        }\n        // TODO: commit on start if there were `urgent` sends;\n        // Clarify where urgent can be used for;\n        // Clarify workflow for each type of message in case it was sent before start\n        //      (like Fetch before start; maybe add an option \"preCapture: boolean\" or sth alike)\n        // Careful: `this.delay` is equal to zero before start so all Timestamp-s will have to be updated on start\n        if (this.activityState === ActivityState.Active && urgent) {\n            this.commit();\n        }\n    }\n    /**\n     * Normal workflow: add timestamp and tab data to batch, then commit it\n     * every ~30ms\n     * */\n    _nCommit() {\n        if (this.worker !== undefined && this.messages.length) {\n            (0, utils_js_1.requestIdleCb)(() => {\n                var _a;\n                this.messages.unshift((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n                this.messages.unshift((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n                // why I need to add opt chaining?\n                (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(this.messages);\n                this.commitCallbacks.forEach((cb) => cb(this.messages));\n                this.messages.length = 0;\n            });\n        }\n    }\n    /**\n     * Cold start: add timestamp and tab data to both batches\n     * every 2nd tick, ~60ms\n     * this will make batches a bit larger and replay will work with bigger jumps every frame\n     * but in turn we don't overload batch writer on session start with 1000 batches\n     * */\n    _cStartCommit() {\n        this.coldStartCommitN += 1;\n        if (this.coldStartCommitN === 2) {\n            this.bufferedMessages1.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n            this.bufferedMessages1.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n            this.bufferedMessages2.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n            this.bufferedMessages2.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n            this.coldStartCommitN = 0;\n        }\n    }\n    commit() {\n        if (this.activityState === ActivityState.ColdStart) {\n            this._cStartCommit();\n        }\n        else {\n            this._nCommit();\n        }\n    }\n    postToWorker(messages) {\n        var _a;\n        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(messages);\n        this.commitCallbacks.forEach((cb) => cb(messages));\n        messages.length = 0;\n    }\n    timestamp() {\n        return (0, utils_js_1.now)() + this.delay;\n    }\n    safe(fn) {\n        const app = this;\n        return function (...args) {\n            try {\n                fn.apply(this, args);\n            }\n            catch (e) {\n                app._debug('safe_fn_call', e);\n                // time: this.timestamp(),\n                // name: e.name,\n                // message: e.message,\n                // stack: e.stack\n            }\n        }; // TODO: correct typing\n    }\n    attachCommitCallback(cb) {\n        this.commitCallbacks.push(cb);\n    }\n    attachStartCallback(cb, useSafe = false) {\n        if (useSafe) {\n            cb = this.safe(cb);\n        }\n        this.startCallbacks.push(cb);\n    }\n    attachStopCallback(cb, useSafe = false) {\n        if (useSafe) {\n            cb = this.safe(cb);\n        }\n        this.stopCallbacks.push(cb);\n    }\n    // Use  app.nodes.attachNodeListener for registered nodes instead\n    attachEventListener(target, type, listener, useSafe = true, useCapture = true) {\n        if (useSafe) {\n            listener = this.safe(listener);\n        }\n        this.attachStartCallback(() => (target ? (0, utils_js_1.createEventListener)(target, type, listener, useCapture) : null), useSafe);\n        this.attachStopCallback(() => (target ? (0, utils_js_1.deleteEventListener)(target, type, listener, useCapture) : null), useSafe);\n    }\n    // TODO: full correct semantic\n    checkRequiredVersion(version) {\n        const reqVer = version.split(/[.-]/);\n        const ver = this.version.split(/[.-]/);\n        for (let i = 0; i < 3; i++) {\n            if (isNaN(Number(ver[i])) || isNaN(Number(reqVer[i]))) {\n                return false;\n            }\n            if (Number(ver[i]) > Number(reqVer[i])) {\n                return true;\n            }\n            if (Number(ver[i]) < Number(reqVer[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getTrackerInfo() {\n        return {\n            userUUID: this.localStorage.getItem(this.options.local_uuid_key),\n            projectKey: this.projectKey,\n            revID: this.revID,\n            trackerVersion: this.version,\n            isSnippet: this.options.__is_snippet,\n        };\n    }\n    getSessionInfo() {\n        return Object.assign(Object.assign({}, this.session.getInfo()), this.getTrackerInfo());\n    }\n    getSessionToken() {\n        return this.session.getSessionToken();\n    }\n    getSessionID() {\n        return this.session.getInfo().sessionID || undefined;\n    }\n    getSessionURL(options) {\n        const { projectID, sessionID, timestamp } = this.session.getInfo();\n        if (!projectID || !sessionID) {\n            this.debug.error('OpenReplay error: Unable to build session URL');\n            return undefined;\n        }\n        const ingest = this.options.ingestPoint;\n        const isSaas = /api\\.openreplay\\.com/.test(ingest);\n        const projectPath = isSaas ? 'https://app.openreplay.com/ingest' : ingest;\n        const url = projectPath.replace(/ingest$/, `${projectID}/session/${sessionID}`);\n        if (options === null || options === void 0 ? void 0 : options.withCurrentTime) {\n            const jumpTo = (0, utils_js_1.now)() - timestamp;\n            return `${url}?jumpto=${jumpTo}`;\n        }\n        return url;\n    }\n    getHost() {\n        return new URL(this.options.ingestPoint).host;\n    }\n    getProjectKey() {\n        return this.projectKey;\n    }\n    getBaseHref() {\n        var _a, _b;\n        if (typeof this.options.resourceBaseHref === 'string') {\n            return this.options.resourceBaseHref;\n        }\n        else if (typeof this.options.resourceBaseHref === 'object') {\n            //TODO: switch between types\n        }\n        if (document.baseURI) {\n            return document.baseURI;\n        }\n        // IE only\n        return (((_b = (_a = document.head) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('base')[0]) === null || _b === void 0 ? void 0 : _b.getAttribute('href')) ||\n            location.origin + location.pathname);\n    }\n    resolveResourceURL(resourceURL) {\n        const base = new URL(this.getBaseHref());\n        base.pathname += '/' + new URL(resourceURL).pathname;\n        base.pathname.replace(/\\/+/g, '/');\n        return base.toString();\n    }\n    isServiceURL(url) {\n        return url.startsWith(this.options.ingestPoint);\n    }\n    active() {\n        return this.activityState === ActivityState.Active;\n    }\n    resetNextPageSession(flag) {\n        if (flag) {\n            this.sessionStorage.setItem(this.options.session_reset_key, 't');\n        }\n        else {\n            this.sessionStorage.removeItem(this.options.session_reset_key);\n        }\n    }\n    checkSessionToken(forceNew) {\n        const lsReset = this.sessionStorage.getItem(this.options.session_reset_key) !== null;\n        const needNewSessionID = forceNew || lsReset;\n        const sessionToken = this.session.getSessionToken();\n        return needNewSessionID || !sessionToken;\n    }\n    /**\n     * start buffering messages without starting the actual session, which gives\n     * user 30 seconds to \"activate\" and record session by calling `start()` on conditional trigger\n     * and we will then send buffered batch, so it won't get lost\n     * */\n    async coldStart(startOpts = {}, conditional) {\n        var _a, _b;\n        this.singleBuffer = false;\n        const second = 1000;\n        if (conditional) {\n            this.conditionsManager = new conditionsManager_js_1.default(this, startOpts);\n        }\n        const isNewSession = this.checkSessionToken(startOpts.forceNew);\n        if (conditional) {\n            const r = await fetch(this.options.ingestPoint + '/v1/web/start', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(Object.assign(Object.assign({}, this.getTrackerInfo()), { timestamp: (0, utils_js_1.now)(), doNotRecord: true, bufferDiff: 0, userID: this.session.getInfo().userID, token: undefined, deviceMemory: performance_js_1.deviceMemory,\n                    jsHeapSizeLimit: performance_js_1.jsHeapSizeLimit, timezone: getTimezone() })),\n            });\n            const { \n            // this token is needed to fetch conditions and flags,\n            // but it can't be used to record a session\n            token, userBrowser, userCity, userCountry, userDevice, userOS, userState, projectID, } = await r.json();\n            this.session.assign({ projectID });\n            this.session.setUserInfo({\n                userBrowser,\n                userCity,\n                userCountry,\n                userDevice,\n                userOS,\n                userState,\n            });\n            const onStartInfo = { sessionToken: token, userUUID: '', sessionID: '' };\n            this.startCallbacks.forEach((cb) => cb(onStartInfo));\n            await ((_a = this.conditionsManager) === null || _a === void 0 ? void 0 : _a.fetchConditions(projectID, token));\n            await this.featureFlags.reloadFlags(token);\n            await this.tagWatcher.fetchTags(this.options.ingestPoint, token);\n            (_b = this.conditionsManager) === null || _b === void 0 ? void 0 : _b.processFlags(this.featureFlags.flags);\n        }\n        const cycle = () => {\n            this.orderNumber += 1;\n            (0, utils_js_1.adjustTimeOrigin)();\n            this.coldStartTs = (0, utils_js_1.now)();\n            if (this.orderNumber % 2 === 0) {\n                this.bufferedMessages1.length = 0;\n                this.bufferedMessages1.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n                this.bufferedMessages1.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n            }\n            else {\n                this.bufferedMessages2.length = 0;\n                this.bufferedMessages2.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n                this.bufferedMessages2.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n            }\n            this.stop(false);\n            this.activityState = ActivityState.ColdStart;\n            if (startOpts.sessionHash) {\n                this.session.applySessionHash(startOpts.sessionHash);\n            }\n            if (startOpts.forceNew) {\n                this.session.reset();\n            }\n            this.session.assign({\n                userID: startOpts.userID,\n                metadata: startOpts.metadata,\n            });\n            if (!isNewSession) {\n                this.debug.log('continuing session on new tab', this.session.getTabId());\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                this.send((0, messages_gen_js_2.TabChange)(this.session.getTabId()));\n            }\n            this.observer.observe();\n            this.ticker.start();\n        };\n        this.coldInterval = setInterval(() => {\n            cycle();\n        }, 30 * second);\n        cycle();\n    }\n    /**\n     * Starts offline session recording\n     * @param {Object} startOpts - options for session start, same as .start()\n     * @param {Function} onSessionSent - callback that will be called once session is fully sent\n     * */\n    offlineRecording(startOpts = {}, onSessionSent) {\n        this.onSessionSent = onSessionSent;\n        this.singleBuffer = true;\n        const isNewSession = this.checkSessionToken(startOpts.forceNew);\n        (0, utils_js_1.adjustTimeOrigin)();\n        this.coldStartTs = (0, utils_js_1.now)();\n        const saverBuffer = this.localStorage.getItem(bufferStorageKey);\n        if (saverBuffer) {\n            const data = JSON.parse(saverBuffer);\n            this.bufferedMessages1 = Array.isArray(data) ? data : this.bufferedMessages1;\n            this.localStorage.removeItem(bufferStorageKey);\n        }\n        this.bufferedMessages1.push((0, messages_gen_js_2.Timestamp)(this.timestamp()));\n        this.bufferedMessages1.push((0, messages_gen_js_2.TabData)(this.session.getTabId()));\n        this.activityState = ActivityState.ColdStart;\n        if (startOpts.sessionHash) {\n            this.session.applySessionHash(startOpts.sessionHash);\n        }\n        if (startOpts.forceNew) {\n            this.session.reset();\n        }\n        this.session.assign({\n            userID: startOpts.userID,\n            metadata: startOpts.metadata,\n        });\n        const onStartInfo = { sessionToken: '', userUUID: '', sessionID: '' };\n        this.startCallbacks.forEach((cb) => cb(onStartInfo));\n        if (!isNewSession) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            this.send((0, messages_gen_js_2.TabChange)(this.session.getTabId()));\n        }\n        this.observer.observe();\n        this.ticker.start();\n        return {\n            saveBuffer: this.saveBuffer,\n            getBuffer: this.getBuffer,\n            setBuffer: this.setBuffer,\n        };\n    }\n    /**\n     * Saves the captured messages in localStorage (or whatever is used in its place)\n     *\n     * Then when this.offlineRecording is called, it will preload this messages and clear the storage item\n     *\n     * Keeping the size of local storage reasonable is up to the end users of this library\n     * */\n    saveBuffer() {\n        this.localStorage.setItem(bufferStorageKey, JSON.stringify(this.bufferedMessages1));\n    }\n    /**\n     * @returns buffer with stored messages for offline recording\n     * */\n    getBuffer() {\n        return this.bufferedMessages1;\n    }\n    /**\n     * Used to set a buffer with messages array\n     * */\n    setBuffer(buffer) {\n        this.bufferedMessages1 = buffer;\n    }\n    /**\n     * Uploads the stored session buffer to backend\n     * @returns promise that resolves once messages are loaded, it has to be awaited\n     * so the session can be uploaded properly\n     * @resolve - if messages were loaded in service worker successfully\n     * @reject {string} - error message\n     * */\n    async uploadOfflineRecording() {\n        var _a, _b;\n        this.stop(false);\n        const timestamp = (0, utils_js_1.now)();\n        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({\n            type: 'start',\n            pageNo: this.session.incPageNo(),\n            ingestPoint: this.options.ingestPoint,\n            timestamp: this.coldStartTs,\n            url: document.URL,\n            connAttemptCount: this.options.connAttemptCount,\n            connAttemptGap: this.options.connAttemptGap,\n            tabId: this.session.getTabId(),\n        });\n        const r = await fetch(this.options.ingestPoint + '/v1/web/start', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(Object.assign(Object.assign({}, this.getTrackerInfo()), { timestamp: timestamp, doNotRecord: false, bufferDiff: timestamp - this.coldStartTs, userID: this.session.getInfo().userID, token: undefined, deviceMemory: performance_js_1.deviceMemory,\n                jsHeapSizeLimit: performance_js_1.jsHeapSizeLimit, timezone: getTimezone() })),\n        });\n        const { token, userBrowser, userCity, userCountry, userDevice, userOS, userState, beaconSizeLimit, projectID, } = await r.json();\n        (_b = this.worker) === null || _b === void 0 ? void 0 : _b.postMessage({\n            type: 'auth',\n            token,\n            beaconSizeLimit,\n        });\n        this.session.assign({ projectID });\n        this.session.setUserInfo({\n            userBrowser,\n            userCity,\n            userCountry,\n            userDevice,\n            userOS,\n            userState,\n        });\n        while (this.bufferedMessages1.length > 0) {\n            await this.flushBuffer(this.bufferedMessages1);\n        }\n        this.postToWorker([['q_end']]);\n        this.clearBuffers();\n    }\n    _start(startOpts = {}, resetByWorker = false, conditionName) {\n        const isColdStart = this.activityState === ActivityState.ColdStart;\n        if (isColdStart && this.coldInterval) {\n            clearInterval(this.coldInterval);\n        }\n        if (!this.worker) {\n            const reason = 'No worker found: perhaps, CSP is not set.';\n            this.signalError(reason, []);\n            return Promise.resolve(UnsuccessfulStart(reason));\n        }\n        if (this.activityState === ActivityState.Active ||\n            this.activityState === ActivityState.Starting) {\n            const reason = 'OpenReplay: trying to call `start()` on the instance that has been started already.';\n            return Promise.resolve(UnsuccessfulStart(reason));\n        }\n        this.activityState = ActivityState.Starting;\n        if (!isColdStart) {\n            (0, utils_js_1.adjustTimeOrigin)();\n        }\n        if (startOpts.sessionHash) {\n            this.session.applySessionHash(startOpts.sessionHash);\n        }\n        if (startOpts.forceNew) {\n            // Reset session metadata only if requested directly\n            this.session.reset();\n        }\n        this.session.assign({\n            // MBTODO: maybe it would make sense to `forceNew` if the `userID` was changed\n            userID: startOpts.userID,\n            metadata: startOpts.metadata,\n        });\n        const timestamp = (0, utils_js_1.now)();\n        this.worker.postMessage({\n            type: 'start',\n            pageNo: this.session.incPageNo(),\n            ingestPoint: this.options.ingestPoint,\n            timestamp: isColdStart ? this.coldStartTs : timestamp,\n            url: document.URL,\n            connAttemptCount: this.options.connAttemptCount,\n            connAttemptGap: this.options.connAttemptGap,\n            tabId: this.session.getTabId(),\n        });\n        const sessionToken = this.session.getSessionToken();\n        const isNewSession = this.checkSessionToken(startOpts.forceNew);\n        this.sessionStorage.removeItem(this.options.session_reset_key);\n        this.debug.log('OpenReplay: starting session; need new session id?', isNewSession, 'session token: ', sessionToken);\n        return window\n            .fetch(this.options.ingestPoint + '/v1/web/start', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(Object.assign(Object.assign({}, this.getTrackerInfo()), { timestamp, doNotRecord: false, bufferDiff: timestamp - this.coldStartTs, userID: this.session.getInfo().userID, token: isNewSession ? undefined : sessionToken, deviceMemory: performance_js_1.deviceMemory,\n                jsHeapSizeLimit: performance_js_1.jsHeapSizeLimit, timezone: getTimezone(), condition: conditionName })),\n        })\n            .then((r) => {\n            if (r.status === 200) {\n                return r.json();\n            }\n            else {\n                return r\n                    .text()\n                    .then((text) => text === CANCELED\n                    ? Promise.reject(CANCELED)\n                    : Promise.reject(`Server error: ${r.status}. ${text}`));\n            }\n        })\n            .then(async (r) => {\n            var _a;\n            if (!this.worker) {\n                const reason = 'no worker found after start request (this might not happen)';\n                this.signalError(reason, []);\n                return Promise.reject(reason);\n            }\n            if (this.activityState === ActivityState.NotActive) {\n                const reason = 'Tracker stopped during authorization';\n                this.signalError(reason, []);\n                return Promise.reject(reason);\n            }\n            const { token, userUUID, projectID, beaconSizeLimit, compressionThreshold, // how big the batch should be before we decide to compress it\n            delay, //  derived from token\n            sessionID, //  derived from token\n            startTimestamp, // real startTS (server time), derived from sessionID\n            userBrowser, userCity, userCountry, userDevice, userOS, userState, canvasEnabled, canvasQuality, canvasFPS, } = r;\n            if (typeof token !== 'string' ||\n                typeof userUUID !== 'string' ||\n                (typeof startTimestamp !== 'number' && typeof startTimestamp !== 'undefined') ||\n                typeof sessionID !== 'string' ||\n                typeof delay !== 'number' ||\n                (typeof beaconSizeLimit !== 'number' && typeof beaconSizeLimit !== 'undefined')) {\n                const reason = `Incorrect server response: ${JSON.stringify(r)}`;\n                this.signalError(reason, []);\n                return Promise.reject(reason);\n            }\n            this.delay = delay;\n            this.session.setSessionToken(token);\n            this.session.setUserInfo({\n                userBrowser,\n                userCity,\n                userCountry,\n                userDevice,\n                userOS,\n                userState,\n            });\n            this.session.assign({\n                sessionID,\n                timestamp: startTimestamp || timestamp,\n                projectID,\n            });\n            this.worker.postMessage({\n                type: 'auth',\n                token,\n                beaconSizeLimit,\n            });\n            if (!isNewSession && token === sessionToken) {\n                this.debug.log('continuing session on new tab', this.session.getTabId());\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                this.send((0, messages_gen_js_2.TabChange)(this.session.getTabId()));\n            }\n            // (Re)send Metadata for the case of a new session\n            Object.entries(this.session.getInfo().metadata).forEach(([key, value]) => this.send((0, messages_gen_js_2.Metadata)(key, value)));\n            this.localStorage.setItem(this.options.local_uuid_key, userUUID);\n            this.compressionThreshold = compressionThreshold;\n            const onStartInfo = { sessionToken: token, userUUID, sessionID };\n            // TODO: start as early as possible (before receiving the token)\n            /** after start */\n            this.startCallbacks.forEach((cb) => cb(onStartInfo)); // MBTODO: callbacks after DOM \"mounted\" (observed)\n            void this.featureFlags.reloadFlags();\n            await this.tagWatcher.fetchTags(this.options.ingestPoint, token);\n            this.activityState = ActivityState.Active;\n            if (canvasEnabled) {\n                this.canvasRecorder =\n                    (_a = this.canvasRecorder) !== null && _a !== void 0 ? _a : new canvas_js_1.default(this, {\n                        fps: canvasFPS,\n                        quality: canvasQuality,\n                        isDebug: this.options.__save_canvas_locally,\n                        fixedScaling: this.options.fixedCanvasScaling,\n                    });\n                this.canvasRecorder.startTracking();\n            }\n            /** --------------- COLD START BUFFER ------------------*/\n            if (isColdStart) {\n                const biggestBuffer = this.bufferedMessages1.length > this.bufferedMessages2.length\n                    ? this.bufferedMessages1\n                    : this.bufferedMessages2;\n                while (biggestBuffer.length > 0) {\n                    await this.flushBuffer(biggestBuffer);\n                }\n                this.clearBuffers();\n                this.commit();\n                /** --------------- COLD START BUFFER ------------------*/\n            }\n            else {\n                this.observer.observe();\n                this.ticker.start();\n            }\n            // get rid of onStart ?\n            if (typeof this.options.onStart === 'function') {\n                this.options.onStart(onStartInfo);\n            }\n            this.restartAttempts = 0;\n            this.uxtManager = this.uxtManager\n                ? this.uxtManager\n                : new index_js_1.default(this, uxtStorageKey);\n            let uxtId;\n            const savedUxtTag = this.localStorage.getItem(uxtStorageKey);\n            if (savedUxtTag) {\n                uxtId = parseInt(savedUxtTag, 10);\n            }\n            if (location === null || location === void 0 ? void 0 : location.search) {\n                const query = new URLSearchParams(location.search);\n                if (query.has('oruxt')) {\n                    const qId = query.get('oruxt');\n                    uxtId = qId ? parseInt(qId, 10) : undefined;\n                }\n            }\n            if (uxtId) {\n                if (!this.uxtManager.isActive) {\n                    // eslint-disable-next-line\n                    this.uxtManager.getTest(uxtId, token, Boolean(savedUxtTag)).then((id) => {\n                        if (id) {\n                            this.onUxtCb.forEach((cb) => cb(id));\n                        }\n                    });\n                }\n                else {\n                    // @ts-ignore\n                    this.onUxtCb.forEach((cb) => cb(uxtId));\n                }\n            }\n            return SuccessfulStart(onStartInfo);\n        })\n            .catch((reason) => {\n            this.stop();\n            this.session.reset();\n            if (reason === CANCELED) {\n                this.signalError(CANCELED, []);\n                return UnsuccessfulStart(CANCELED);\n            }\n            this._debug('session_start', reason);\n            this.signalError(START_ERROR, []);\n            return UnsuccessfulStart(START_ERROR);\n        });\n    }\n    addOnUxtCb(cb) {\n        // @ts-ignore\n        this.onUxtCb.push(cb);\n    }\n    getUxtId() {\n        var _a;\n        return (_a = this.uxtManager) === null || _a === void 0 ? void 0 : _a.getTestId();\n    }\n    /**\n     * basically we ask other tabs during constructor\n     * and here we just apply 10ms delay just in case\n     * */\n    start(...args) {\n        if (!document.hidden) {\n            return new Promise((resolve) => {\n                setTimeout(() => {\n                    resolve(this._start(...args));\n                }, 25);\n            });\n        }\n        else {\n            return new Promise((resolve) => {\n                const onVisibilityChange = () => {\n                    if (!document.hidden) {\n                        document.removeEventListener('visibilitychange', onVisibilityChange);\n                        setTimeout(() => {\n                            resolve(this._start(...args));\n                        }, 25);\n                    }\n                };\n                document.addEventListener('visibilitychange', onVisibilityChange);\n            });\n        }\n    }\n    forceFlushBatch() {\n        var _a;\n        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage('forceFlushBatch');\n    }\n    getTabId() {\n        return this.session.getTabId();\n    }\n    clearBuffers() {\n        this.bufferedMessages1.length = 0;\n        this.bufferedMessages2.length = 0;\n    }\n    /**\n     * Creates a named hook that expects event name, data string and msg direction (up/down),\n     * it will skip any message bigger than 5 mb or event name bigger than 255 symbols\n     * @returns {(msgType: string, data: string, dir: \"up\" | \"down\") => void}\n     * */\n    trackWs(channelName) {\n        const channel = channelName;\n        return (msgType, data, dir = 'down') => {\n            if (typeof msgType !== 'string' ||\n                typeof data !== 'string' ||\n                data.length > 5 * 1024 * 1024 ||\n                msgType.length > 255) {\n                return;\n            }\n            this.send((0, messages_gen_js_2.WSChannel)('websocket', channel, data, this.timestamp(), dir, msgType));\n        };\n    }\n    stop(stopWorker = true) {\n        var _a;\n        if (this.activityState !== ActivityState.NotActive) {\n            try {\n                this.attributeSender.clear();\n                this.sanitizer.clear();\n                this.observer.disconnect();\n                this.nodes.clear();\n                this.ticker.stop();\n                this.stopCallbacks.forEach((cb) => cb());\n                this.debug.log('OpenReplay tracking stopped.');\n                this.tagWatcher.clear();\n                if (this.worker && stopWorker) {\n                    this.worker.postMessage('stop');\n                }\n                (_a = this.canvasRecorder) === null || _a === void 0 ? void 0 : _a.clear();\n            }\n            finally {\n                this.activityState = ActivityState.NotActive;\n            }\n        }\n    }\n}\nexports.default = App;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}