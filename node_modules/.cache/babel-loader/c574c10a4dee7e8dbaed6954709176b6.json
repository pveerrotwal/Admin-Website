{"ast":null,"code":"// License: MIT\n// Author: Anton Medvedev <anton@medv.io>\n// Source: https://github.com/antonmedv/finder\nlet config;\nlet rootDocument;\nexport function finder(input, options) {\n  if (input.nodeType !== Node.ELEMENT_NODE) {\n    throw new Error(`Can't generate CSS selector for non-element node type.`);\n  }\n  if ('html' === input.tagName.toLowerCase()) {\n    return 'html';\n  }\n  const defaults = {\n    root: document.body,\n    idName: name => true,\n    className: name => true,\n    tagName: name => true,\n    attr: (name, value) => false,\n    seedMinLength: 1,\n    optimizedMinLength: 2,\n    threshold: 1000,\n    maxNumberOfTries: 10000\n  };\n  config = {\n    ...defaults,\n    ...options\n  };\n  rootDocument = findRootDocument(config.root, defaults);\n  let path = bottomUpSearch(input, 'all', () => bottomUpSearch(input, 'two', () => bottomUpSearch(input, 'one', () => bottomUpSearch(input, 'none'))));\n  if (path) {\n    const optimized = sort(optimize(path, input));\n    if (optimized.length > 0) {\n      path = optimized[0];\n    }\n    return selector(path);\n  } else {\n    throw new Error(`Selector was not found.`);\n  }\n}\nfunction findRootDocument(rootNode, defaults) {\n  if (rootNode.nodeType === Node.DOCUMENT_NODE) {\n    return rootNode;\n  }\n  if (rootNode === defaults.root) {\n    return rootNode.ownerDocument;\n  }\n  return rootNode;\n}\nfunction bottomUpSearch(input, limit, fallback) {\n  let path = null;\n  let stack = [];\n  let current = input;\n  let i = 0;\n  while (current) {\n    let level = maybe(id(current)) || maybe(...attr(current)) || maybe(...classNames(current)) || maybe(tagName(current)) || [any()];\n    const nth = index(current);\n    if (limit == 'all') {\n      if (nth) {\n        level = level.concat(level.filter(dispensableNth).map(node => nthChild(node, nth)));\n      }\n    } else if (limit == 'two') {\n      level = level.slice(0, 1);\n      if (nth) {\n        level = level.concat(level.filter(dispensableNth).map(node => nthChild(node, nth)));\n      }\n    } else if (limit == 'one') {\n      const [node] = level = level.slice(0, 1);\n      if (nth && dispensableNth(node)) {\n        level = [nthChild(node, nth)];\n      }\n    } else if (limit == 'none') {\n      level = [any()];\n      if (nth) {\n        level = [nthChild(level[0], nth)];\n      }\n    }\n    for (let node of level) {\n      node.level = i;\n    }\n    stack.push(level);\n    if (stack.length >= config.seedMinLength) {\n      path = findUniquePath(stack, fallback);\n      if (path) {\n        break;\n      }\n    }\n    current = current.parentElement;\n    i++;\n  }\n  if (!path) {\n    path = findUniquePath(stack, fallback);\n  }\n  if (!path && fallback) {\n    return fallback();\n  }\n  return path;\n}\nfunction findUniquePath(stack, fallback) {\n  const paths = sort(combinations(stack));\n  if (paths.length > config.threshold) {\n    return fallback ? fallback() : null;\n  }\n  for (let candidate of paths) {\n    if (unique(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}\nfunction selector(path) {\n  let node = path[0];\n  let query = node.name;\n  for (let i = 1; i < path.length; i++) {\n    const level = path[i].level || 0;\n    if (node.level === level - 1) {\n      query = `${path[i].name} > ${query}`;\n    } else {\n      query = `${path[i].name} ${query}`;\n    }\n    node = path[i];\n  }\n  return query;\n}\nfunction penalty(path) {\n  return path.map(node => node.penalty).reduce((acc, i) => acc + i, 0);\n}\nfunction unique(path) {\n  const css = selector(path);\n  switch (rootDocument.querySelectorAll(css).length) {\n    case 0:\n      throw new Error(`Can't select any node with this selector: ${css}`);\n    case 1:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction id(input) {\n  const elementId = input.getAttribute('id');\n  if (elementId && config.idName(elementId)) {\n    return {\n      name: '#' + CSS.escape(elementId),\n      penalty: 0\n    };\n  }\n  return null;\n}\nfunction attr(input) {\n  const attrs = Array.from(input.attributes).filter(attr => config.attr(attr.name, attr.value));\n  return attrs.map(attr => ({\n    name: `[${CSS.escape(attr.name)}=\"${CSS.escape(attr.value)}\"]`,\n    penalty: 0.5\n  }));\n}\nfunction classNames(input) {\n  const names = Array.from(input.classList).filter(config.className);\n  return names.map(name => ({\n    name: '.' + CSS.escape(name),\n    penalty: 1\n  }));\n}\nfunction tagName(input) {\n  const name = input.tagName.toLowerCase();\n  if (config.tagName(name)) {\n    return {\n      name,\n      penalty: 2\n    };\n  }\n  return null;\n}\nfunction any() {\n  return {\n    name: '*',\n    penalty: 3\n  };\n}\nfunction index(input) {\n  const parent = input.parentNode;\n  if (!parent) {\n    return null;\n  }\n  let child = parent.firstChild;\n  if (!child) {\n    return null;\n  }\n  let i = 0;\n  while (child) {\n    if (child.nodeType === Node.ELEMENT_NODE) {\n      i++;\n    }\n    if (child === input) {\n      break;\n    }\n    child = child.nextSibling;\n  }\n  return i;\n}\nfunction nthChild(node, i) {\n  return {\n    name: node.name + `:nth-child(${i})`,\n    penalty: node.penalty + 1\n  };\n}\nfunction dispensableNth(node) {\n  return node.name !== 'html' && !node.name.startsWith('#');\n}\nfunction maybe(...level) {\n  const list = level.filter(notEmpty);\n  if (list.length > 0) {\n    return list;\n  }\n  return null;\n}\nfunction notEmpty(value) {\n  return value !== null && value !== undefined;\n}\nfunction* combinations(stack, path = []) {\n  if (stack.length > 0) {\n    for (let node of stack[0]) {\n      yield* combinations(stack.slice(1, stack.length), path.concat(node));\n    }\n  } else {\n    yield path;\n  }\n}\nfunction sort(paths) {\n  return [...paths].sort((a, b) => penalty(a) - penalty(b));\n}\nfunction* optimize(path, input, scope = {\n  counter: 0,\n  visited: new Map()\n}) {\n  if (path.length > 2 && path.length > config.optimizedMinLength) {\n    for (let i = 1; i < path.length - 1; i++) {\n      if (scope.counter > config.maxNumberOfTries) {\n        return; // Okay At least I tried!\n      }\n      scope.counter += 1;\n      const newPath = [...path];\n      newPath.splice(i, 1);\n      const newPathKey = selector(newPath);\n      if (scope.visited.has(newPathKey)) {\n        return;\n      }\n      if (unique(newPath) && same(newPath, input)) {\n        yield newPath;\n        scope.visited.set(newPathKey, true);\n        yield* optimize(newPath, input, scope);\n      }\n    }\n  }\n}\nfunction same(path, input) {\n  return rootDocument.querySelector(selector(path)) === input;\n}","map":{"version":3,"names":["config","rootDocument","finder","input","options","nodeType","Node","ELEMENT_NODE","Error","tagName","toLowerCase","defaults","root","document","body","idName","name","className","attr","value","seedMinLength","optimizedMinLength","threshold","maxNumberOfTries","findRootDocument","path","bottomUpSearch","optimized","sort","optimize","length","selector","rootNode","DOCUMENT_NODE","ownerDocument","limit","fallback","stack","current","i","level","maybe","id","classNames","any","nth","index","concat","filter","dispensableNth","map","node","nthChild","slice","push","findUniquePath","parentElement","paths","combinations","candidate","unique","query","penalty","reduce","acc","css","querySelectorAll","elementId","getAttribute","CSS","escape","attrs","Array","from","attributes","names","classList","parent","parentNode","child","firstChild","nextSibling","startsWith","list","notEmpty","undefined","a","b","scope","counter","visited","Map","newPath","splice","newPathKey","has","same","set","querySelector"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@medv/finder/finder.js"],"sourcesContent":["// License: MIT\n// Author: Anton Medvedev <anton@medv.io>\n// Source: https://github.com/antonmedv/finder\nlet config;\nlet rootDocument;\nexport function finder(input, options) {\n    if (input.nodeType !== Node.ELEMENT_NODE) {\n        throw new Error(`Can't generate CSS selector for non-element node type.`);\n    }\n    if ('html' === input.tagName.toLowerCase()) {\n        return 'html';\n    }\n    const defaults = {\n        root: document.body,\n        idName: (name) => true,\n        className: (name) => true,\n        tagName: (name) => true,\n        attr: (name, value) => false,\n        seedMinLength: 1,\n        optimizedMinLength: 2,\n        threshold: 1000,\n        maxNumberOfTries: 10000,\n    };\n    config = { ...defaults, ...options };\n    rootDocument = findRootDocument(config.root, defaults);\n    let path = bottomUpSearch(input, 'all', () => bottomUpSearch(input, 'two', () => bottomUpSearch(input, 'one', () => bottomUpSearch(input, 'none'))));\n    if (path) {\n        const optimized = sort(optimize(path, input));\n        if (optimized.length > 0) {\n            path = optimized[0];\n        }\n        return selector(path);\n    }\n    else {\n        throw new Error(`Selector was not found.`);\n    }\n}\nfunction findRootDocument(rootNode, defaults) {\n    if (rootNode.nodeType === Node.DOCUMENT_NODE) {\n        return rootNode;\n    }\n    if (rootNode === defaults.root) {\n        return rootNode.ownerDocument;\n    }\n    return rootNode;\n}\nfunction bottomUpSearch(input, limit, fallback) {\n    let path = null;\n    let stack = [];\n    let current = input;\n    let i = 0;\n    while (current) {\n        let level = maybe(id(current)) ||\n            maybe(...attr(current)) ||\n            maybe(...classNames(current)) ||\n            maybe(tagName(current)) || [any()];\n        const nth = index(current);\n        if (limit == 'all') {\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));\n            }\n        }\n        else if (limit == 'two') {\n            level = level.slice(0, 1);\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));\n            }\n        }\n        else if (limit == 'one') {\n            const [node] = (level = level.slice(0, 1));\n            if (nth && dispensableNth(node)) {\n                level = [nthChild(node, nth)];\n            }\n        }\n        else if (limit == 'none') {\n            level = [any()];\n            if (nth) {\n                level = [nthChild(level[0], nth)];\n            }\n        }\n        for (let node of level) {\n            node.level = i;\n        }\n        stack.push(level);\n        if (stack.length >= config.seedMinLength) {\n            path = findUniquePath(stack, fallback);\n            if (path) {\n                break;\n            }\n        }\n        current = current.parentElement;\n        i++;\n    }\n    if (!path) {\n        path = findUniquePath(stack, fallback);\n    }\n    if (!path && fallback) {\n        return fallback();\n    }\n    return path;\n}\nfunction findUniquePath(stack, fallback) {\n    const paths = sort(combinations(stack));\n    if (paths.length > config.threshold) {\n        return fallback ? fallback() : null;\n    }\n    for (let candidate of paths) {\n        if (unique(candidate)) {\n            return candidate;\n        }\n    }\n    return null;\n}\nfunction selector(path) {\n    let node = path[0];\n    let query = node.name;\n    for (let i = 1; i < path.length; i++) {\n        const level = path[i].level || 0;\n        if (node.level === level - 1) {\n            query = `${path[i].name} > ${query}`;\n        }\n        else {\n            query = `${path[i].name} ${query}`;\n        }\n        node = path[i];\n    }\n    return query;\n}\nfunction penalty(path) {\n    return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);\n}\nfunction unique(path) {\n    const css = selector(path);\n    switch (rootDocument.querySelectorAll(css).length) {\n        case 0:\n            throw new Error(`Can't select any node with this selector: ${css}`);\n        case 1:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction id(input) {\n    const elementId = input.getAttribute('id');\n    if (elementId && config.idName(elementId)) {\n        return {\n            name: '#' + CSS.escape(elementId),\n            penalty: 0,\n        };\n    }\n    return null;\n}\nfunction attr(input) {\n    const attrs = Array.from(input.attributes).filter((attr) => config.attr(attr.name, attr.value));\n    return attrs.map((attr) => ({\n        name: `[${CSS.escape(attr.name)}=\"${CSS.escape(attr.value)}\"]`,\n        penalty: 0.5,\n    }));\n}\nfunction classNames(input) {\n    const names = Array.from(input.classList).filter(config.className);\n    return names.map((name) => ({\n        name: '.' + CSS.escape(name),\n        penalty: 1,\n    }));\n}\nfunction tagName(input) {\n    const name = input.tagName.toLowerCase();\n    if (config.tagName(name)) {\n        return {\n            name,\n            penalty: 2,\n        };\n    }\n    return null;\n}\nfunction any() {\n    return {\n        name: '*',\n        penalty: 3,\n    };\n}\nfunction index(input) {\n    const parent = input.parentNode;\n    if (!parent) {\n        return null;\n    }\n    let child = parent.firstChild;\n    if (!child) {\n        return null;\n    }\n    let i = 0;\n    while (child) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            i++;\n        }\n        if (child === input) {\n            break;\n        }\n        child = child.nextSibling;\n    }\n    return i;\n}\nfunction nthChild(node, i) {\n    return {\n        name: node.name + `:nth-child(${i})`,\n        penalty: node.penalty + 1,\n    };\n}\nfunction dispensableNth(node) {\n    return node.name !== 'html' && !node.name.startsWith('#');\n}\nfunction maybe(...level) {\n    const list = level.filter(notEmpty);\n    if (list.length > 0) {\n        return list;\n    }\n    return null;\n}\nfunction notEmpty(value) {\n    return value !== null && value !== undefined;\n}\nfunction* combinations(stack, path = []) {\n    if (stack.length > 0) {\n        for (let node of stack[0]) {\n            yield* combinations(stack.slice(1, stack.length), path.concat(node));\n        }\n    }\n    else {\n        yield path;\n    }\n}\nfunction sort(paths) {\n    return [...paths].sort((a, b) => penalty(a) - penalty(b));\n}\nfunction* optimize(path, input, scope = {\n    counter: 0,\n    visited: new Map(),\n}) {\n    if (path.length > 2 && path.length > config.optimizedMinLength) {\n        for (let i = 1; i < path.length - 1; i++) {\n            if (scope.counter > config.maxNumberOfTries) {\n                return; // Okay At least I tried!\n            }\n            scope.counter += 1;\n            const newPath = [...path];\n            newPath.splice(i, 1);\n            const newPathKey = selector(newPath);\n            if (scope.visited.has(newPathKey)) {\n                return;\n            }\n            if (unique(newPath) && same(newPath, input)) {\n                yield newPath;\n                scope.visited.set(newPathKey, true);\n                yield* optimize(newPath, input, scope);\n            }\n        }\n    }\n}\nfunction same(path, input) {\n    return rootDocument.querySelector(selector(path)) === input;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}