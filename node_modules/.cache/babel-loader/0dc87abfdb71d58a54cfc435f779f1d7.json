{"ast":null,"code":"import { NetworkRequest } from '../app/messages.gen.js';\nimport { getTimeOrigin } from '../utils.js';\nimport axiosSpy from './axiosSpy.js';\nimport setProxy from './Network/index.js';\nfunction getXHRRequestDataObject(xhr) {\n  // @ts-ignore  this is 3x faster than using Map<XHR, XHRRequestData>\n  if (!xhr.__or_req_data__) {\n    // @ts-ignore\n    xhr.__or_req_data__ = {\n      body: undefined,\n      headers: {}\n    };\n  }\n  // @ts-ignore\n  return xhr.__or_req_data__;\n}\nfunction strMethod(method) {\n  return typeof method === 'string' ? method.toUpperCase() : 'GET';\n}\nexport default function (app, opts = {}) {\n  const options = Object.assign({\n    failuresOnly: false,\n    ignoreHeaders: ['cookie', 'set-cookie', 'authorization'],\n    capturePayload: false,\n    sessionTokenHeader: false,\n    captureInIframes: true,\n    axiosInstances: undefined,\n    useProxy: true\n  }, opts);\n  if (options.useProxy === false) {\n    app.debug.warn('Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true');\n  }\n  const ignoreHeaders = options.ignoreHeaders;\n  const isHIgnored = Array.isArray(ignoreHeaders) ? name => ignoreHeaders.includes(name) : () => ignoreHeaders;\n  const stHeader = options.sessionTokenHeader === true ? 'X-OpenReplay-SessionToken' : options.sessionTokenHeader;\n  function setSessionTokenHeader(setRequestHeader) {\n    if (stHeader) {\n      const sessionToken = app.getSessionToken();\n      if (sessionToken) {\n        app.safe(setRequestHeader)(stHeader, sessionToken);\n      }\n    }\n  }\n  function sanitize(reqResInfo) {\n    if (!options.capturePayload) {\n      // @ts-ignore\n      delete reqResInfo.request.body;\n      delete reqResInfo.response.body;\n    }\n    if (options.sanitizer) {\n      const resBody = reqResInfo.response.body;\n      if (typeof resBody === 'string') {\n        // Parse response in order to have handy view in sanitization function\n        try {\n          reqResInfo.response.body = JSON.parse(resBody);\n        } catch (_a) {}\n      }\n      return options.sanitizer(reqResInfo);\n    }\n    return reqResInfo;\n  }\n  function stringify(r) {\n    if (r && typeof r.body !== 'string') {\n      try {\n        r.body = JSON.stringify(r.body);\n      } catch (_a) {\n        r.body = '<unable to stringify>';\n        app.notify.warn(\"Openreplay fetch couldn't stringify body:\", r.body);\n      }\n    }\n    return JSON.stringify(r);\n  }\n  const patchWindow = context => {\n    /* ====== modern way ====== */\n    if (options.useProxy) {\n      return setProxy(context, options.ignoreHeaders, setSessionTokenHeader, sanitize, message => app.send(message), url => app.isServiceURL(url), options.tokenUrlMatcher);\n    }\n    /* ====== Fetch ====== */\n    const origFetch = context.fetch.bind(context);\n    const trackFetch = (input, init = {}) => {\n      if (!(typeof input === 'string' || input instanceof URL) || app.isServiceURL(String(input))) {\n        return origFetch(input, init);\n      }\n      setSessionTokenHeader(function (name, value) {\n        if (init.headers === undefined) {\n          init.headers = {};\n        }\n        if (init.headers instanceof Headers) {\n          init.headers.append(name, value);\n        } else if (Array.isArray(init.headers)) {\n          init.headers.push([name, value]);\n        } else {\n          init.headers[name] = value;\n        }\n      });\n      const startTime = performance.now();\n      return origFetch(input, init).then(response => {\n        const duration = performance.now() - startTime;\n        if (options.failuresOnly && response.status < 400) {\n          return response;\n        }\n        const r = response.clone();\n        r.text().then(text => {\n          const reqHs = {};\n          const resHs = {};\n          if (ignoreHeaders !== true) {\n            // request headers\n            const writeReqHeader = ([n, v]) => {\n              if (!isHIgnored(n)) {\n                reqHs[n] = v;\n              }\n            };\n            if (init.headers instanceof Headers) {\n              init.headers.forEach((v, n) => writeReqHeader([n, v]));\n            } else if (Array.isArray(init.headers)) {\n              init.headers.forEach(writeReqHeader);\n            } else if (typeof init.headers === 'object') {\n              Object.entries(init.headers).forEach(writeReqHeader);\n            }\n            // response headers\n            r.headers.forEach((v, n) => {\n              if (!isHIgnored(n)) resHs[n] = v;\n            });\n          }\n          const method = strMethod(init.method);\n          const reqResInfo = sanitize({\n            url: String(input),\n            method,\n            status: r.status,\n            request: {\n              headers: reqHs,\n              // @ts-ignore\n              body: init.body || null\n            },\n            response: {\n              headers: resHs,\n              body: text\n            }\n          });\n          if (!reqResInfo) {\n            return;\n          }\n          app.send(NetworkRequest('fetch', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), r.status, startTime + getTimeOrigin(), duration, 0));\n        }).catch(e => app.debug.error('Could not process Fetch response:', e));\n        return response;\n      });\n    };\n    // @ts-ignore\n    context.fetch = trackFetch;\n    /* ====== <> ====== */\n    /* ====== XHR ====== */\n    const nativeOpen = context.XMLHttpRequest.prototype.open;\n    const nativeSetRequestHeader = context.XMLHttpRequest.prototype.setRequestHeader;\n    const nativeSend = context.XMLHttpRequest.prototype.send;\n    function trackXMLHttpReqOpen(initMethod, url) {\n      const xhr = this;\n      setSessionTokenHeader((name, value) => xhr.setRequestHeader(name, value));\n      let startTime = 0;\n      xhr.addEventListener('loadstart', e => {\n        startTime = e.timeStamp;\n      });\n      xhr.addEventListener('load', app.safe(e => {\n        const {\n          headers: reqHs,\n          body: reqBody\n        } = getXHRRequestDataObject(xhr);\n        const duration = startTime > 0 ? e.timeStamp - startTime : 0;\n        const hString = xhr.getAllResponseHeaders() || ''; // might be null (only if no response received though)\n        const headersArr = hString.trim().split(/[\\r\\n]+/);\n        const headerMap = {};\n        headersArr.forEach(function (line) {\n          const parts = line.split(': ');\n          const header = parts.shift();\n          if (!isHIgnored(header)) {\n            headerMap[header] = parts.join(': ');\n          }\n        });\n        const method = strMethod(initMethod);\n        const reqResInfo = sanitize({\n          url: String(url),\n          method,\n          status: xhr.status,\n          request: {\n            headers: reqHs,\n            // @ts-ignore\n            body: reqBody || null\n          },\n          response: {\n            headers: headerMap,\n            body: xhr.response\n          }\n        });\n        if (!reqResInfo) {\n          return;\n        }\n        app.send(NetworkRequest('xhr', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), xhr.status, startTime + getTimeOrigin(), duration, 0));\n      }));\n      //TODO: handle error (though it has no Error API nor any useful information)\n      //xhr.addEventListener('error', (e) => {})\n      return nativeOpen.apply(this, arguments);\n    }\n    function trackXHRSend(body) {\n      const rdo = getXHRRequestDataObject(this);\n      rdo.body = body;\n      // @ts-ignore ??? this -> XMLHttpRequest\n      return nativeSend.apply(this, arguments);\n    }\n    function trackSetReqHeader(name, value) {\n      if (!isHIgnored(name)) {\n        const rdo = getXHRRequestDataObject(this);\n        rdo.headers[name] = value;\n      }\n      return nativeSetRequestHeader.apply(this, arguments);\n    }\n    if (!options.axiosInstances) {\n      context.XMLHttpRequest.prototype.open = trackXMLHttpReqOpen;\n      context.XMLHttpRequest.prototype.send = trackXHRSend;\n      context.XMLHttpRequest.prototype.setRequestHeader = trackSetReqHeader;\n    }\n    /* ====== <> ====== */\n  };\n  patchWindow(window);\n  if (options.axiosInstances) {\n    options.axiosInstances.forEach(axiosInstance => {\n      axiosSpy(app, axiosInstance, options, sanitize, stringify);\n    });\n  }\n  if (options.captureInIframes) {\n    app.observer.attachContextCallback(app.safe(patchWindow));\n  }\n}","map":{"version":3,"names":["NetworkRequest","getTimeOrigin","axiosSpy","setProxy","getXHRRequestDataObject","xhr","__or_req_data__","body","undefined","headers","strMethod","method","toUpperCase","app","opts","options","Object","assign","failuresOnly","ignoreHeaders","capturePayload","sessionTokenHeader","captureInIframes","axiosInstances","useProxy","debug","warn","isHIgnored","Array","isArray","name","includes","stHeader","setSessionTokenHeader","setRequestHeader","sessionToken","getSessionToken","safe","sanitize","reqResInfo","request","response","sanitizer","resBody","JSON","parse","_a","stringify","r","notify","patchWindow","context","message","send","url","isServiceURL","tokenUrlMatcher","origFetch","fetch","bind","trackFetch","input","init","URL","String","value","Headers","append","push","startTime","performance","now","then","duration","status","clone","text","reqHs","resHs","writeReqHeader","n","v","forEach","entries","catch","e","error","nativeOpen","XMLHttpRequest","prototype","open","nativeSetRequestHeader","nativeSend","trackXMLHttpReqOpen","initMethod","addEventListener","timeStamp","reqBody","hString","getAllResponseHeaders","headersArr","trim","split","headerMap","line","parts","header","shift","join","apply","arguments","trackXHRSend","rdo","trackSetReqHeader","window","axiosInstance","observer","attachContextCallback"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/lib/modules/network.js"],"sourcesContent":["import { NetworkRequest } from '../app/messages.gen.js';\nimport { getTimeOrigin } from '../utils.js';\nimport axiosSpy from './axiosSpy.js';\nimport setProxy from './Network/index.js';\nfunction getXHRRequestDataObject(xhr) {\n    // @ts-ignore  this is 3x faster than using Map<XHR, XHRRequestData>\n    if (!xhr.__or_req_data__) {\n        // @ts-ignore\n        xhr.__or_req_data__ = { body: undefined, headers: {} };\n    }\n    // @ts-ignore\n    return xhr.__or_req_data__;\n}\nfunction strMethod(method) {\n    return typeof method === 'string' ? method.toUpperCase() : 'GET';\n}\nexport default function (app, opts = {}) {\n    const options = Object.assign({\n        failuresOnly: false,\n        ignoreHeaders: ['cookie', 'set-cookie', 'authorization'],\n        capturePayload: false,\n        sessionTokenHeader: false,\n        captureInIframes: true,\n        axiosInstances: undefined,\n        useProxy: true,\n    }, opts);\n    if (options.useProxy === false) {\n        app.debug.warn('Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true');\n    }\n    const ignoreHeaders = options.ignoreHeaders;\n    const isHIgnored = Array.isArray(ignoreHeaders)\n        ? (name) => ignoreHeaders.includes(name)\n        : () => ignoreHeaders;\n    const stHeader = options.sessionTokenHeader === true ? 'X-OpenReplay-SessionToken' : options.sessionTokenHeader;\n    function setSessionTokenHeader(setRequestHeader) {\n        if (stHeader) {\n            const sessionToken = app.getSessionToken();\n            if (sessionToken) {\n                app.safe(setRequestHeader)(stHeader, sessionToken);\n            }\n        }\n    }\n    function sanitize(reqResInfo) {\n        if (!options.capturePayload) {\n            // @ts-ignore\n            delete reqResInfo.request.body;\n            delete reqResInfo.response.body;\n        }\n        if (options.sanitizer) {\n            const resBody = reqResInfo.response.body;\n            if (typeof resBody === 'string') {\n                // Parse response in order to have handy view in sanitization function\n                try {\n                    reqResInfo.response.body = JSON.parse(resBody);\n                }\n                catch (_a) { }\n            }\n            return options.sanitizer(reqResInfo);\n        }\n        return reqResInfo;\n    }\n    function stringify(r) {\n        if (r && typeof r.body !== 'string') {\n            try {\n                r.body = JSON.stringify(r.body);\n            }\n            catch (_a) {\n                r.body = '<unable to stringify>';\n                app.notify.warn(\"Openreplay fetch couldn't stringify body:\", r.body);\n            }\n        }\n        return JSON.stringify(r);\n    }\n    const patchWindow = (context) => {\n        /* ====== modern way ====== */\n        if (options.useProxy) {\n            return setProxy(context, options.ignoreHeaders, setSessionTokenHeader, sanitize, (message) => app.send(message), (url) => app.isServiceURL(url), options.tokenUrlMatcher);\n        }\n        /* ====== Fetch ====== */\n        const origFetch = context.fetch.bind(context);\n        const trackFetch = (input, init = {}) => {\n            if (!(typeof input === 'string' || input instanceof URL) || app.isServiceURL(String(input))) {\n                return origFetch(input, init);\n            }\n            setSessionTokenHeader(function (name, value) {\n                if (init.headers === undefined) {\n                    init.headers = {};\n                }\n                if (init.headers instanceof Headers) {\n                    init.headers.append(name, value);\n                }\n                else if (Array.isArray(init.headers)) {\n                    init.headers.push([name, value]);\n                }\n                else {\n                    init.headers[name] = value;\n                }\n            });\n            const startTime = performance.now();\n            return origFetch(input, init).then((response) => {\n                const duration = performance.now() - startTime;\n                if (options.failuresOnly && response.status < 400) {\n                    return response;\n                }\n                const r = response.clone();\n                r.text()\n                    .then((text) => {\n                    const reqHs = {};\n                    const resHs = {};\n                    if (ignoreHeaders !== true) {\n                        // request headers\n                        const writeReqHeader = ([n, v]) => {\n                            if (!isHIgnored(n)) {\n                                reqHs[n] = v;\n                            }\n                        };\n                        if (init.headers instanceof Headers) {\n                            init.headers.forEach((v, n) => writeReqHeader([n, v]));\n                        }\n                        else if (Array.isArray(init.headers)) {\n                            init.headers.forEach(writeReqHeader);\n                        }\n                        else if (typeof init.headers === 'object') {\n                            Object.entries(init.headers).forEach(writeReqHeader);\n                        }\n                        // response headers\n                        r.headers.forEach((v, n) => {\n                            if (!isHIgnored(n))\n                                resHs[n] = v;\n                        });\n                    }\n                    const method = strMethod(init.method);\n                    const reqResInfo = sanitize({\n                        url: String(input),\n                        method,\n                        status: r.status,\n                        request: {\n                            headers: reqHs,\n                            // @ts-ignore\n                            body: init.body || null,\n                        },\n                        response: {\n                            headers: resHs,\n                            body: text,\n                        },\n                    });\n                    if (!reqResInfo) {\n                        return;\n                    }\n                    app.send(NetworkRequest('fetch', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), r.status, startTime + getTimeOrigin(), duration, 0));\n                })\n                    .catch((e) => app.debug.error('Could not process Fetch response:', e));\n                return response;\n            });\n        };\n        // @ts-ignore\n        context.fetch = trackFetch;\n        /* ====== <> ====== */\n        /* ====== XHR ====== */\n        const nativeOpen = context.XMLHttpRequest.prototype.open;\n        const nativeSetRequestHeader = context.XMLHttpRequest.prototype.setRequestHeader;\n        const nativeSend = context.XMLHttpRequest.prototype.send;\n        function trackXMLHttpReqOpen(initMethod, url) {\n            const xhr = this;\n            setSessionTokenHeader((name, value) => xhr.setRequestHeader(name, value));\n            let startTime = 0;\n            xhr.addEventListener('loadstart', (e) => {\n                startTime = e.timeStamp;\n            });\n            xhr.addEventListener('load', app.safe((e) => {\n                const { headers: reqHs, body: reqBody } = getXHRRequestDataObject(xhr);\n                const duration = startTime > 0 ? e.timeStamp - startTime : 0;\n                const hString = xhr.getAllResponseHeaders() || ''; // might be null (only if no response received though)\n                const headersArr = hString.trim().split(/[\\r\\n]+/);\n                const headerMap = {};\n                headersArr.forEach(function (line) {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    if (!isHIgnored(header)) {\n                        headerMap[header] = parts.join(': ');\n                    }\n                });\n                const method = strMethod(initMethod);\n                const reqResInfo = sanitize({\n                    url: String(url),\n                    method,\n                    status: xhr.status,\n                    request: {\n                        headers: reqHs,\n                        // @ts-ignore\n                        body: reqBody || null,\n                    },\n                    response: {\n                        headers: headerMap,\n                        body: xhr.response,\n                    },\n                });\n                if (!reqResInfo) {\n                    return;\n                }\n                app.send(NetworkRequest('xhr', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), xhr.status, startTime + getTimeOrigin(), duration, 0));\n            }));\n            //TODO: handle error (though it has no Error API nor any useful information)\n            //xhr.addEventListener('error', (e) => {})\n            return nativeOpen.apply(this, arguments);\n        }\n        function trackXHRSend(body) {\n            const rdo = getXHRRequestDataObject(this);\n            rdo.body = body;\n            // @ts-ignore ??? this -> XMLHttpRequest\n            return nativeSend.apply(this, arguments);\n        }\n        function trackSetReqHeader(name, value) {\n            if (!isHIgnored(name)) {\n                const rdo = getXHRRequestDataObject(this);\n                rdo.headers[name] = value;\n            }\n            return nativeSetRequestHeader.apply(this, arguments);\n        }\n        if (!options.axiosInstances) {\n            context.XMLHttpRequest.prototype.open = trackXMLHttpReqOpen;\n            context.XMLHttpRequest.prototype.send = trackXHRSend;\n            context.XMLHttpRequest.prototype.setRequestHeader = trackSetReqHeader;\n        }\n        /* ====== <> ====== */\n    };\n    patchWindow(window);\n    if (options.axiosInstances) {\n        options.axiosInstances.forEach((axiosInstance) => {\n            axiosSpy(app, axiosInstance, options, sanitize, stringify);\n        });\n    }\n    if (options.captureInIframes) {\n        app.observer.attachContextCallback(app.safe(patchWindow));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}