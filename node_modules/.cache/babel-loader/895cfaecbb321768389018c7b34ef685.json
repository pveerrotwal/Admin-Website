{"ast":null,"code":"import { hasTag } from './guards.js';\nimport { CanvasNode } from './messages.gen.js';\nclass CanvasRecorder {\n  constructor(app, options) {\n    this.app = app;\n    this.options = options;\n    this.snapshots = {};\n    this.intervals = [];\n    this.restartTracking = () => {\n      this.clear();\n      this.app.nodes.scanTree(this.captureCanvas);\n    };\n    this.captureCanvas = node => {\n      const id = this.app.nodes.getID(node);\n      if (!id || !hasTag(node, 'canvas')) {\n        return;\n      }\n      const isIgnored = this.app.sanitizer.isObscured(id) || this.app.sanitizer.isHidden(id);\n      if (isIgnored || !hasTag(node, 'canvas') || this.snapshots[id]) {\n        return;\n      }\n      const observer = new IntersectionObserver(entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            if (entry.target) {\n              if (this.snapshots[id] && this.snapshots[id].createdAt) {\n                this.snapshots[id].paused = false;\n              } else {\n                this.recordCanvas(entry.target, id);\n              }\n              /**\n               * We can switch this to start observing when element is in the view\n               * but otherwise right now we're just pausing when it's not\n               * just to save some bandwidth and space on backend\n               * */\n              // observer.unobserve(entry.target)\n            } else {\n              if (this.snapshots[id]) {\n                this.snapshots[id].paused = true;\n              }\n            }\n          }\n        });\n      });\n      observer.observe(node);\n    };\n    this.recordCanvas = (node, id) => {\n      const ts = this.app.timestamp();\n      this.snapshots[id] = {\n        images: [],\n        createdAt: ts,\n        paused: false,\n        dummy: document.createElement('canvas')\n      };\n      const canvasMsg = CanvasNode(id.toString(), ts);\n      this.app.send(canvasMsg);\n      const int = setInterval(() => {\n        const cid = this.app.nodes.getID(node);\n        const canvas = cid ? this.app.nodes.getNode(cid) : undefined;\n        if (!canvas || !hasTag(canvas, 'canvas') || canvas !== node) {\n          this.app.debug.log('Canvas element not in sync');\n          clearInterval(int);\n        } else {\n          if (!this.snapshots[id].paused) {\n            const snapshot = captureSnapshot(canvas, this.options.quality, this.snapshots[id].dummy, this.options.fixedScaling);\n            this.snapshots[id].images.push({\n              id: this.app.timestamp(),\n              data: snapshot\n            });\n            if (this.snapshots[id].images.length > 9) {\n              this.sendSnaps(this.snapshots[id].images, id, this.snapshots[id].createdAt);\n              this.snapshots[id].images = [];\n            }\n          }\n        }\n      }, this.interval);\n      this.intervals.push(int);\n    };\n    this.interval = 1000 / options.fps;\n  }\n  startTracking() {\n    setTimeout(() => {\n      this.app.nodes.scanTree(this.captureCanvas);\n      this.app.nodes.attachNodeCallback(node => {\n        this.captureCanvas(node);\n      });\n    }, 500);\n  }\n  sendSnaps(images, canvasId, createdAt) {\n    var _a;\n    if (Object.keys(this.snapshots).length === 0) {\n      return;\n    }\n    const formData = new FormData();\n    images.forEach(snapshot => {\n      const blob = dataUrlToBlob(snapshot.data);\n      if (!blob) return;\n      formData.append('snapshot', blob[0], `${createdAt}_${canvasId}_${snapshot.id}.jpeg`);\n      if (this.options.isDebug) {\n        saveImageData(snapshot.data, `${createdAt}_${canvasId}_${snapshot.id}.jpeg`);\n      }\n    });\n    fetch(this.app.options.ingestPoint + '/v1/web/images', {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${(_a = this.app.session.getSessionToken()) !== null && _a !== void 0 ? _a : ''}`\n      },\n      body: formData\n    }).then(() => {\n      return true;\n    }).catch(e => {\n      this.app.debug.error('error saving canvas', e);\n    });\n  }\n  clear() {\n    this.intervals.forEach(int => clearInterval(int));\n    this.snapshots = {};\n  }\n}\nconst qualityInt = {\n  low: 0.35,\n  medium: 0.55,\n  high: 0.8\n};\nfunction captureSnapshot(canvas, quality = 'medium', dummy, fixedScaling = false) {\n  const imageFormat = 'image/jpeg'; // or /png'\n  if (fixedScaling) {\n    const canvasScaleRatio = window.devicePixelRatio || 1;\n    dummy.width = canvas.width / canvasScaleRatio;\n    dummy.height = canvas.height / canvasScaleRatio;\n    const ctx = dummy.getContext('2d');\n    if (!ctx) {\n      return '';\n    }\n    ctx.drawImage(canvas, 0, 0, dummy.width, dummy.height);\n    return dummy.toDataURL(imageFormat, qualityInt[quality]);\n  } else {\n    return canvas.toDataURL(imageFormat, qualityInt[quality]);\n  }\n}\nfunction dataUrlToBlob(dataUrl) {\n  const [header, base64] = dataUrl.split(',');\n  if (!header || !base64) return null;\n  const encParts = header.match(/:(.*?);/);\n  if (!encParts) return null;\n  const mime = encParts[1];\n  const blobStr = atob(base64);\n  let n = blobStr.length;\n  const u8arr = new Uint8Array(n);\n  while (n--) {\n    u8arr[n] = blobStr.charCodeAt(n);\n  }\n  return [new Blob([u8arr], {\n    type: mime\n  }), u8arr];\n}\nfunction saveImageData(imageDataUrl, name) {\n  const link = document.createElement('a');\n  link.href = imageDataUrl;\n  link.download = name;\n  link.style.display = 'none';\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n}\nexport default CanvasRecorder;","map":{"version":3,"names":["hasTag","CanvasNode","CanvasRecorder","constructor","app","options","snapshots","intervals","restartTracking","clear","nodes","scanTree","captureCanvas","node","id","getID","isIgnored","sanitizer","isObscured","isHidden","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","target","createdAt","paused","recordCanvas","observe","ts","timestamp","images","dummy","document","createElement","canvasMsg","toString","send","int","setInterval","cid","canvas","getNode","undefined","debug","log","clearInterval","snapshot","captureSnapshot","quality","fixedScaling","push","data","length","sendSnaps","interval","fps","startTracking","setTimeout","attachNodeCallback","canvasId","_a","Object","keys","formData","FormData","blob","dataUrlToBlob","append","isDebug","saveImageData","fetch","ingestPoint","method","headers","Authorization","session","getSessionToken","body","then","catch","e","error","qualityInt","low","medium","high","imageFormat","canvasScaleRatio","window","devicePixelRatio","width","height","ctx","getContext","drawImage","toDataURL","dataUrl","header","base64","split","encParts","match","mime","blobStr","atob","n","u8arr","Uint8Array","charCodeAt","Blob","type","imageDataUrl","name","link","href","download","style","display","appendChild","click","removeChild"],"sources":["/Users/paramvirrotwal/Observability/website-admin-react-web-app-project/node_modules/@openreplay/tracker/lib/app/canvas.js"],"sourcesContent":["import { hasTag } from './guards.js';\nimport { CanvasNode } from './messages.gen.js';\nclass CanvasRecorder {\n    constructor(app, options) {\n        this.app = app;\n        this.options = options;\n        this.snapshots = {};\n        this.intervals = [];\n        this.restartTracking = () => {\n            this.clear();\n            this.app.nodes.scanTree(this.captureCanvas);\n        };\n        this.captureCanvas = (node) => {\n            const id = this.app.nodes.getID(node);\n            if (!id || !hasTag(node, 'canvas')) {\n                return;\n            }\n            const isIgnored = this.app.sanitizer.isObscured(id) || this.app.sanitizer.isHidden(id);\n            if (isIgnored || !hasTag(node, 'canvas') || this.snapshots[id]) {\n                return;\n            }\n            const observer = new IntersectionObserver((entries) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        if (entry.target) {\n                            if (this.snapshots[id] && this.snapshots[id].createdAt) {\n                                this.snapshots[id].paused = false;\n                            }\n                            else {\n                                this.recordCanvas(entry.target, id);\n                            }\n                            /**\n                             * We can switch this to start observing when element is in the view\n                             * but otherwise right now we're just pausing when it's not\n                             * just to save some bandwidth and space on backend\n                             * */\n                            // observer.unobserve(entry.target)\n                        }\n                        else {\n                            if (this.snapshots[id]) {\n                                this.snapshots[id].paused = true;\n                            }\n                        }\n                    }\n                });\n            });\n            observer.observe(node);\n        };\n        this.recordCanvas = (node, id) => {\n            const ts = this.app.timestamp();\n            this.snapshots[id] = {\n                images: [],\n                createdAt: ts,\n                paused: false,\n                dummy: document.createElement('canvas'),\n            };\n            const canvasMsg = CanvasNode(id.toString(), ts);\n            this.app.send(canvasMsg);\n            const int = setInterval(() => {\n                const cid = this.app.nodes.getID(node);\n                const canvas = cid ? this.app.nodes.getNode(cid) : undefined;\n                if (!canvas || !hasTag(canvas, 'canvas') || canvas !== node) {\n                    this.app.debug.log('Canvas element not in sync');\n                    clearInterval(int);\n                }\n                else {\n                    if (!this.snapshots[id].paused) {\n                        const snapshot = captureSnapshot(canvas, this.options.quality, this.snapshots[id].dummy, this.options.fixedScaling);\n                        this.snapshots[id].images.push({ id: this.app.timestamp(), data: snapshot });\n                        if (this.snapshots[id].images.length > 9) {\n                            this.sendSnaps(this.snapshots[id].images, id, this.snapshots[id].createdAt);\n                            this.snapshots[id].images = [];\n                        }\n                    }\n                }\n            }, this.interval);\n            this.intervals.push(int);\n        };\n        this.interval = 1000 / options.fps;\n    }\n    startTracking() {\n        setTimeout(() => {\n            this.app.nodes.scanTree(this.captureCanvas);\n            this.app.nodes.attachNodeCallback((node) => {\n                this.captureCanvas(node);\n            });\n        }, 500);\n    }\n    sendSnaps(images, canvasId, createdAt) {\n        var _a;\n        if (Object.keys(this.snapshots).length === 0) {\n            return;\n        }\n        const formData = new FormData();\n        images.forEach((snapshot) => {\n            const blob = dataUrlToBlob(snapshot.data);\n            if (!blob)\n                return;\n            formData.append('snapshot', blob[0], `${createdAt}_${canvasId}_${snapshot.id}.jpeg`);\n            if (this.options.isDebug) {\n                saveImageData(snapshot.data, `${createdAt}_${canvasId}_${snapshot.id}.jpeg`);\n            }\n        });\n        fetch(this.app.options.ingestPoint + '/v1/web/images', {\n            method: 'POST',\n            headers: {\n                Authorization: `Bearer ${(_a = this.app.session.getSessionToken()) !== null && _a !== void 0 ? _a : ''}`,\n            },\n            body: formData,\n        })\n            .then(() => {\n            return true;\n        })\n            .catch((e) => {\n            this.app.debug.error('error saving canvas', e);\n        });\n    }\n    clear() {\n        this.intervals.forEach((int) => clearInterval(int));\n        this.snapshots = {};\n    }\n}\nconst qualityInt = {\n    low: 0.35,\n    medium: 0.55,\n    high: 0.8,\n};\nfunction captureSnapshot(canvas, quality = 'medium', dummy, fixedScaling = false) {\n    const imageFormat = 'image/jpeg'; // or /png'\n    if (fixedScaling) {\n        const canvasScaleRatio = window.devicePixelRatio || 1;\n        dummy.width = canvas.width / canvasScaleRatio;\n        dummy.height = canvas.height / canvasScaleRatio;\n        const ctx = dummy.getContext('2d');\n        if (!ctx) {\n            return '';\n        }\n        ctx.drawImage(canvas, 0, 0, dummy.width, dummy.height);\n        return dummy.toDataURL(imageFormat, qualityInt[quality]);\n    }\n    else {\n        return canvas.toDataURL(imageFormat, qualityInt[quality]);\n    }\n}\nfunction dataUrlToBlob(dataUrl) {\n    const [header, base64] = dataUrl.split(',');\n    if (!header || !base64)\n        return null;\n    const encParts = header.match(/:(.*?);/);\n    if (!encParts)\n        return null;\n    const mime = encParts[1];\n    const blobStr = atob(base64);\n    let n = blobStr.length;\n    const u8arr = new Uint8Array(n);\n    while (n--) {\n        u8arr[n] = blobStr.charCodeAt(n);\n    }\n    return [new Blob([u8arr], { type: mime }), u8arr];\n}\nfunction saveImageData(imageDataUrl, name) {\n    const link = document.createElement('a');\n    link.href = imageDataUrl;\n    link.download = name;\n    link.style.display = 'none';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n}\nexport default CanvasRecorder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}