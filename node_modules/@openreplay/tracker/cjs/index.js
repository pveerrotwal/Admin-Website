"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SanitizeLevel = exports.Messages = exports.App = void 0;
const index_js_1 = __importStar(require("./app/index.js"));
var index_js_2 = require("./app/index.js");
Object.defineProperty(exports, "App", { enumerable: true, get: function () { return __importDefault(index_js_2).default; } });
const messages_gen_js_1 = require("./app/messages.gen.js");
const _Messages = __importStar(require("./app/messages.gen.js"));
exports.Messages = _Messages;
var sanitizer_js_1 = require("./app/sanitizer.js");
Object.defineProperty(exports, "SanitizeLevel", { enumerable: true, get: function () { return sanitizer_js_1.SanitizeLevel; } });
const connection_js_1 = __importDefault(require("./modules/connection.js"));
const console_js_1 = __importDefault(require("./modules/console.js"));
const exception_js_1 = __importStar(require("./modules/exception.js"));
const img_js_1 = __importDefault(require("./modules/img.js"));
const input_js_1 = __importDefault(require("./modules/input.js"));
const mouse_js_1 = __importDefault(require("./modules/mouse.js"));
const timing_js_1 = __importDefault(require("./modules/timing.js"));
const performance_js_1 = __importDefault(require("./modules/performance.js"));
const scroll_js_1 = __importDefault(require("./modules/scroll.js"));
const viewport_js_1 = __importDefault(require("./modules/viewport.js"));
const cssrules_js_1 = __importDefault(require("./modules/cssrules.js"));
const focus_js_1 = __importDefault(require("./modules/focus.js"));
const fonts_js_1 = __importDefault(require("./modules/fonts.js"));
const network_js_1 = __importDefault(require("./modules/network.js"));
const constructedStyleSheets_js_1 = __importDefault(require("./modules/constructedStyleSheets.js"));
const selection_js_1 = __importDefault(require("./modules/selection.js"));
const tabs_js_1 = __importDefault(require("./modules/tabs.js"));
const utils_js_1 = require("./utils.js");
const DOCS_SETUP = '/installation/javascript-sdk';
function processOptions(obj) {
    if (obj == null) {
        console.error(`OpenReplay: invalid options argument type. Please, check documentation on ${utils_js_1.DOCS_HOST}${DOCS_SETUP}`);
        return false;
    }
    if (typeof obj.projectKey !== 'string') {
        if (typeof obj.projectKey !== 'number') {
            if (typeof obj.projectID !== 'number') {
                // Back compatability
                console.error(`OpenReplay: projectKey is missing or wrong type (string is expected). Please, check ${utils_js_1.DOCS_HOST}${DOCS_SETUP} for more information.`);
                return false;
            }
            else {
                obj.projectKey = obj.projectID.toString();
                (0, utils_js_1.deprecationWarn)('`projectID` option', '`projectKey` option', DOCS_SETUP);
            }
        }
        else {
            console.warn('OpenReplay: projectKey is expected to have a string type.');
            obj.projectKey = obj.projectKey.toString();
        }
    }
    if (obj.sessionToken != null) {
        (0, utils_js_1.deprecationWarn)('`sessionToken` option', '`sessionHash` start() option', '/');
    }
    return true;
}
class API {
    constructor(options) {
        var _a;
        this.options = options;
        this.app = null;
        this.checkDoNotTrack = () => {
            return (this.options.respectDoNotTrack &&
                (navigator.doNotTrack == '1' ||
                    // @ts-ignore
                    window.doNotTrack == '1'));
        };
        this.signalStartIssue = (reason, missingApi) => {
            const doNotTrack = this.checkDoNotTrack();
            const req = new XMLHttpRequest();
            const orig = this.options.ingestPoint || index_js_1.DEFAULT_INGEST_POINT;
            req.open('POST', orig + '/v1/web/not-started');
            req.send(JSON.stringify({
                trackerVersion: '12.0.3',
                projectKey: this.options.projectKey,
                doNotTrack,
                reason,
                missingApi,
            }));
        };
        this.restartCanvasTracking = () => {
            if (this.app === null) {
                return;
            }
            this.app.restartCanvasTracking();
        };
        this.handleError = (e, metadata = {}) => {
            if (this.app === null) {
                return;
            }
            if (e instanceof Error) {
                const msg = (0, exception_js_1.getExceptionMessage)(e, [], metadata);
                this.app.send(msg);
            }
            else if (e instanceof ErrorEvent ||
                ('PromiseRejectionEvent' in window && e instanceof PromiseRejectionEvent)) {
                const msg = (0, exception_js_1.getExceptionMessageFromEvent)(e, undefined, metadata);
                if (msg != null) {
                    this.app.send(msg);
                }
            }
        };
        if (!utils_js_1.IN_BROWSER || !processOptions(options)) {
            return;
        }
        if (window.__OPENREPLAY__) {
            console.error('OpenReplay: one tracker instance has been initialised already');
            return;
        }
        if (!options.__DISABLE_SECURE_MODE && location.protocol !== 'https:') {
            console.error('OpenReplay: Your website must be publicly accessible and running on SSL in order for OpenReplay to properly capture and replay the user session. You can disable this check by setting `__DISABLE_SECURE_MODE` option to `true` if you are testing in localhost. Keep in mind, that asset files on a local machine are not available to the outside world. This might affect tracking if you use css files.');
            return;
        }
        const doNotTrack = this.checkDoNotTrack();
        const failReason = [];
        const conditions = [
            'Map',
            'Set',
            'MutationObserver',
            'performance',
            'timing',
            'startsWith',
            'Blob',
            'Worker',
        ];
        if (doNotTrack) {
            failReason.push('doNotTrack');
        }
        else {
            for (const condition of conditions) {
                if (condition === 'timing') {
                    if ('performance' in window && !(condition in performance)) {
                        failReason.push(condition);
                        break;
                    }
                }
                else if (condition === 'startsWith') {
                    if (!(condition in String.prototype)) {
                        failReason.push(condition);
                        break;
                    }
                }
                else {
                    if (!(condition in window)) {
                        failReason.push(condition);
                        break;
                    }
                }
            }
        }
        if (failReason.length > 0) {
            const missingApi = failReason.join(',');
            console.error(`OpenReplay: browser doesn't support API required for tracking or doNotTrack is set to 1. Reason: ${missingApi}`);
            this.signalStartIssue('missing_api', failReason);
            return;
        }
        const app = new index_js_1.default(options.projectKey, options.sessionToken, options, this.signalStartIssue);
        this.app = app;
        (0, viewport_js_1.default)(app);
        (0, cssrules_js_1.default)(app);
        (0, constructedStyleSheets_js_1.default)(app);
        (0, connection_js_1.default)(app);
        (0, console_js_1.default)(app, options);
        (0, exception_js_1.default)(app, options);
        (0, img_js_1.default)(app);
        (0, input_js_1.default)(app, options);
        (0, mouse_js_1.default)(app, options.mouse);
        (0, timing_js_1.default)(app, options);
        (0, performance_js_1.default)(app, options);
        (0, scroll_js_1.default)(app);
        (0, focus_js_1.default)(app);
        (0, fonts_js_1.default)(app);
        (0, network_js_1.default)(app, options.network);
        (0, selection_js_1.default)(app);
        (0, tabs_js_1.default)(app);
        window.__OPENREPLAY__ = this;
        if ((_a = options.flags) === null || _a === void 0 ? void 0 : _a.onFlagsLoad) {
            this.onFlagsLoad(options.flags.onFlagsLoad);
        }
        const wOpen = window.open;
        if (options.autoResetOnWindowOpen || options.resetTabOnWindowOpen) {
            app.attachStartCallback(() => {
                var _a;
                const tabId = app.getTabId();
                const sessStorage = (_a = app.sessionStorage) !== null && _a !== void 0 ? _a : window.sessionStorage;
                // @ts-ignore ?
                window.open = function (...args) {
                    if (options.autoResetOnWindowOpen) {
                        app.resetNextPageSession(true);
                    }
                    if (options.resetTabOnWindowOpen) {
                        sessStorage.removeItem(options.session_tabid_key || '__openreplay_tabid');
                    }
                    wOpen.call(window, ...args);
                    app.resetNextPageSession(false);
                    sessStorage.setItem(options.session_tabid_key || '__openreplay_tabid', tabId);
                };
            });
            app.attachStopCallback(() => {
                window.open = wOpen;
            });
        }
    }
    isFlagEnabled(flagName) {
        return this.featureFlags.isFlagEnabled(flagName);
    }
    onFlagsLoad(callback) {
        var _a;
        (_a = this.app) === null || _a === void 0 ? void 0 : _a.featureFlags.onFlagsLoad(callback);
    }
    clearPersistFlags() {
        var _a;
        (_a = this.app) === null || _a === void 0 ? void 0 : _a.featureFlags.clearPersistFlags();
    }
    reloadFlags() {
        var _a;
        return (_a = this.app) === null || _a === void 0 ? void 0 : _a.featureFlags.reloadFlags();
    }
    getFeatureFlag(flagName) {
        var _a;
        return (_a = this.app) === null || _a === void 0 ? void 0 : _a.featureFlags.getFeatureFlag(flagName);
    }
    getAllFeatureFlags() {
        var _a;
        return (_a = this.app) === null || _a === void 0 ? void 0 : _a.featureFlags.flags;
    }
    use(fn) {
        return fn(this.app, this.options);
    }
    isActive() {
        if (this.app === null) {
            return false;
        }
        return this.app.active();
    }
    /**
     * Creates a named hook that expects event name, data string and msg direction (up/down),
     * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
     * msg direction is "down" (incoming) by default
     *
     * @returns {(msgType: string, data: string, dir: 'up' | 'down') => void}
     * */
    trackWs(channelName) {
        if (this.app === null) {
            return;
        }
        return this.app.trackWs(channelName);
    }
    start(startOpts) {
        if (this.browserEnvCheck()) {
            if (this.app === null) {
                return Promise.reject("Browser doesn't support required api, or doNotTrack is active.");
            }
            return this.app.start(startOpts);
        }
        else {
            return Promise.reject('Trying to start not in browser.');
        }
    }
    browserEnvCheck() {
        if (!utils_js_1.IN_BROWSER) {
            console.error(`OpenReplay: you are trying to start Tracker on a node.js environment. If you want to use OpenReplay with SSR, please, use componentDidMount or useEffect API for placing the \`tracker.start()\` line. Check documentation on ${utils_js_1.DOCS_HOST}${DOCS_SETUP}`);
            return false;
        }
        return true;
    }
    /**
     * start buffering messages without starting the actual session, which gives user 30 seconds to "activate" and record
     * session by calling start() on conditional trigger and we will then send buffered batch, so it won't get lost
     * */
    coldStart(startOpts, conditional) {
        if (this.browserEnvCheck()) {
            if (this.app === null) {
                return Promise.reject('Tracker not initialized');
            }
            void this.app.coldStart(startOpts, conditional);
        }
        else {
            return Promise.reject('Trying to start not in browser.');
        }
    }
    /**
     * Starts offline session recording. Keep in mind that only user device time will be used for timestamps.
     * (no backend delay sync)
     *
     * @param {Object} startOpts - options for session start, same as .start()
     * @param {Function} onSessionSent - callback that will be called once session is fully sent
     * @returns methods to manipulate buffer:
     *
     * saveBuffer - to save it in localStorage
     *
     * getBuffer - returns current buffer
     *
     * setBuffer - replaces current buffer with given
     * */
    startOfflineRecording(startOpts, onSessionSent) {
        if (this.browserEnvCheck()) {
            if (this.app === null) {
                return Promise.reject('Tracker not initialized');
            }
            return this.app.offlineRecording(startOpts, onSessionSent);
        }
        else {
            return Promise.reject('Trying to start not in browser.');
        }
    }
    /**
     * Uploads the stored session buffer to backend
     * @returns promise that resolves once messages are loaded, it has to be awaited
     * so the session can be uploaded properly
     * @resolve - if messages were loaded into service worker successfully
     * @reject {string} - error message
     * */
    uploadOfflineRecording() {
        if (this.app === null) {
            return;
        }
        return this.app.uploadOfflineRecording();
    }
    stop() {
        if (this.app === null) {
            return;
        }
        this.app.stop();
        return this.app.session.getSessionHash();
    }
    forceFlushBatch() {
        if (this.app === null) {
            return;
        }
        this.app.forceFlushBatch();
    }
    getSessionToken() {
        if (this.app === null) {
            return null;
        }
        return this.app.getSessionToken();
    }
    getSessionID() {
        if (this.app === null) {
            return null;
        }
        return this.app.getSessionID();
    }
    getTabId() {
        if (this.app === null) {
            return null;
        }
        return this.app.getTabId();
    }
    getUxId() {
        if (this.app === null) {
            return null;
        }
        return this.app.getUxtId();
    }
    sessionID() {
        (0, utils_js_1.deprecationWarn)("'sessionID' method", "'getSessionID' method", '/');
        return this.getSessionID();
    }
    getSessionURL(options) {
        if (this.app === null) {
            return undefined;
        }
        return this.app.getSessionURL(options);
    }
    setUserID(id) {
        if (typeof id === 'string' && this.app !== null) {
            this.app.session.setUserID(id);
        }
    }
    userID(id) {
        (0, utils_js_1.deprecationWarn)("'userID' method", "'setUserID' method", '/');
        this.setUserID(id);
    }
    setUserAnonymousID(id) {
        if (typeof id === 'string' && this.app !== null) {
            this.app.send((0, messages_gen_js_1.UserAnonymousID)(id));
        }
    }
    userAnonymousID(id) {
        (0, utils_js_1.deprecationWarn)("'userAnonymousID' method", "'setUserAnonymousID' method", '/');
        this.setUserAnonymousID(id);
    }
    setMetadata(key, value) {
        if (typeof key === 'string' && typeof value === 'string' && this.app !== null) {
            this.app.session.setMetadata(key, value);
        }
    }
    metadata(key, value) {
        (0, utils_js_1.deprecationWarn)("'metadata' method", "'setMetadata' method", '/');
        this.setMetadata(key, value);
    }
    event(key, payload = null, issue = false) {
        if (typeof key === 'string' && this.app !== null) {
            if (issue) {
                return this.issue(key, payload);
            }
            else {
                try {
                    payload = JSON.stringify(payload);
                }
                catch (e) {
                    return;
                }
                this.app.send((0, messages_gen_js_1.CustomEvent)(key, payload));
            }
        }
    }
    issue(key, payload = null) {
        if (typeof key === 'string' && this.app !== null) {
            try {
                payload = JSON.stringify(payload);
            }
            catch (e) {
                return;
            }
            this.app.send((0, messages_gen_js_1.CustomIssue)(key, payload));
        }
    }
}
exports.default = API;
